# 02語法

## 過濾（Filtering）

### `Where`: 基於條件過濾序列  
  
基本用法: 根據條件過濾序列。

```C#
var numbers = new List<int> { 1, 6, 2, 9, 5 };
var filteredNumbers = numbers.Where(n => n > 5);
```

多載用法: 使用元素的索引作為過濾條件。

```C#
var filteredWithIndex = numbers.Where((num, index) => index % 2 == 0);
```

## 排序（Ordering）

### `OrderBy`: 按指定鍵值升序排序  

基本用法:

```C#
var students = new List<Student> { /* ... */ };
var sortedStudents = students.OrderBy(s => s.Age);
```

---------

### `OrderByDescending`: 按指定鍵值降序排序

基本用法:

```C#
var descendingSortedStudents = students.OrderByDescending(s => s.Age);
```

---------

### `ThenBy`: 在前一個排序條件之後進行二級排序（升序）

基本用法:

```C#
var sortedByName = students.OrderBy(s => s.LastName).ThenBy(s => s.FirstName);
```

---------

### `ThenByDescending`: 在前一個排序條件之後進行二級排序（降序）

基本用法:

```C#
var sortedByNameDesc = students.OrderBy(s => s.LastName).ThenByDescending(s => s.FirstName);
```

---------

### `Reverse`: 反轉序列中元素的順序

基本用法:

```C#
var numbers = new List<int> { 1, 2, 3, 4, 5 };
numbers.Reverse();
```

## 投影（Projection）

### `Select`: 投影每個元素到一個新形式

#### 1. 基本投影

轉換集合中的元素到一個新的形式。

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var squares = numbers.Select(x => x * x); // 將每個數字映射到其平方
```

#### 2. 投影到新類型

創建一個新的物件類型。

```csharp
var students = new List<Student> { /* ... */ };
var studentDTOs = students.Select(s => new StudentDTO { Name = s.Name, Age = s.Age });
```

#### 3. 使用索引

在Lambda中使用元素的索引。

```csharp
var words = new List<string> { "apple", "banana", "cherry" };
var indexedWords = words.Select((word, index) => new { Index = index, Word = word });
```

#### 4. 條件性投影

根據條件改變投影的結果。

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var labels = numbers.Select(n => n % 2 == 0 ? "Even" : "Odd");
```

#### 5. 複雜類型的投影

從複雜對象中選擇多個屬性。

```csharp
var orders = new List<Order> { /* ... */ };
var orderInfos = orders.Select(o => new { o.OrderId, o.Customer.Name, o.TotalAmount });
```

#### 6. 鏈接投影

將 `Select` 與其他 LINQ 方法結合使用。

```csharp
var students = new List<Student> { /* ... */ };
var topStudentNames = students.Where(s => s.Grade > 90).Select(s => s.Name);
```

---------

### `SelectMany`: 將序列的序列平坦化為一個序列

特別有用於處理嵌套集合或多級結構的數據

#### 1. 基本使用 - 扁平化嵌套集合

當每個元素本身是一個集合時，將這些集合合併成一個單一的序列。

```csharp
var listOfLists = new List<List<int>>
{
    new List<int> { 1, 2, 3 },
    new List<int> { 4, 5, 6 },
    new List<int> { 7, 8, 9 }
};

var flattened = listOfLists.SelectMany(x => x);
// 結果: 1, 2, 3, 4, 5, 6, 7, 8, 9
```

#### 2. 投影並扁平化

對集合的每個元素進行處理，並將結果扁平化。

```csharp
public class Course
{
    public string CourseName { get; set; }
}

public class Student
{
    public string Name { get; set; }
    public List<Course> Courses { get; set; }
}
var students = new List<Student>
{
    new Student {
        Name = "Alice",
        Courses = new List<Course> {
            new Course { CourseName = "Math" },
            new Course { CourseName = "English" }
        }
    },
    new Student {
        Name = "Bob",
        Courses = new List<Course> {
            new Course { CourseName = "Science" },
            new Course { CourseName = "History" }
        }
    }
};
var allCourses = students.SelectMany(s => s.Courses).Select(c => c.CourseName).ToList();

foreach (var course in allCourses)
{
    Console.WriteLine(course);
} 
// 扁平化學生的課程列表，得到所有學生的所有課程。
```

#### 3. 結合多個集合

允許對來自原始元素和其相關集合的元素進行投影。

```csharp
var chars = new List<char> { 'A', 'B', 'C' };
var numbers = new List<int> { 1, 2, 3 };

var combinations = chars.SelectMany(c => numbers, (c, n) => $"{c}{n}");
// 結果: "A1", "A2", "A3", "B1", "B2", "B3", "C1", "C2", "C3"
```

```csharp
var listOfPairs = new List<(int, List<string>)>
{
    (1, new List<string> { "a", "b" }),
    (2, new List<string> { "c", "d" })
};

var pairFlattened = listOfPairs.SelectMany(
    pair => pair.Item2, 
    (pair, item) => $"{pair.Item1}{item}"
);
// 結果: "1a", "1b", "2c", "2d"
```

#### 4. 使用索引

函數接受兩個參數：元素和其在原始序列中的索引。

```csharp
var listOfLists = new List<List<int>>
{
    new List<int> { 1, 2 },
    new List<int> { 3, 4 }
};

var indexedFlattened = listOfLists.SelectMany((subList, index) => subList.Select(item => new { index, item }));
// 結果: { index = 0, item = 1 }, { index = 0, item = 2 }, { index = 1, item = 3 }, { index = 1, item = 4 }
```

#### 5. 扁平化複雜數據結構

用於更複雜的數據結構，如多層嵌套集合。

定義 `School`、`Class` 和 `Student` 類：

```csharp
public class School
{
    public string Name { get; set; }
    public List<Class> Classes { get; set; }
}

public class Class
{
    public string ClassName { get; set; }
    public List<Student> Students { get; set; }
}

public class Student
{
    public string Name { get; set; }
}
```

然後，我們創建一個包含學校、班級和學生的列表：

```csharp
var schools = new List<School>
{
    new School
    {
        Name = "School A",
        Classes = new List<Class>
        {
            new Class
            {
                ClassName = "Class 1A",
                Students = new List<Student>
                {
                    new Student { Name = "Alice" },
                    new Student { Name = "Bob" }
                }
            },
            new Class
            {
                ClassName = "Class 1B",
                Students = new List<Student>
                {
                    new Student { Name = "Charlie" },
                    new Student { Name = "David" }
                }
            }
        }
    },
    new School
    {
        Name = "School B",
        Classes = new List<Class>
        {
            new Class
            {
                ClassName = "Class 2A",
                Students = new List<Student>
                {
                    new Student { Name = "Emma" },
                    new Student { Name = "Frank" }
                }
            }
        }
    }
};
```

最後，使用 `SelectMany` 提取所有學校的所有班級的所有學生：

```csharp
var allStudents = schools.SelectMany(school => school.Classes.SelectMany(class => class.Students)).ToList();

foreach (var student in allStudents)
{
    Console.WriteLine(student.Name);
}
```

## 分組（Grouping）

### `GroupBy`: 根據鍵值將序列元素分組

#### 多載 1: `GroupBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>)`

**使用說明**: 根據單一鍵值選擇器函數進行分組。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
var groupedByParity = numbers.GroupBy(n => n % 2 == 0 ? "Even" : "Odd");

foreach (var group in groupedByParity)
{
    Console.WriteLine($"{group.Key}: [{string.Join(", ", group)}]");
}

// 預期輸出:
// Odd: [1, 3, 5, 7, 9]
// Even: [2, 4, 6, 8]
```

#### 多載 2: `GroupBy<TSource, TKey, TElement>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TElement>)`

**使用說明**: 使用鍵值選擇器函數和元素選擇器函數。

**範例**:

```csharp
var students = new List<Student>
{
    new Student { Name = "Alice", Grade = 90 },
    new Student { Name = "Bob", Grade = 80 },
    new Student { Name = "Charlie", Grade = 90 }
};

var groupedByGrade = students.GroupBy(s => s.Grade, s => s.Name);

foreach (var group in groupedByGrade)
{
    Console.WriteLine($"Grade {group.Key}: [{string.Join(", ", group)}]");
}

// 預期輸出:
// Grade 90: [Alice, Charlie]
// Grade 80: [Bob]
```

#### 多載 3: `GroupBy<TSource, TKey, TResult>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TKey, IEnumerable<TSource>, TResult>)`

**使用說明**: 使用鍵值選擇器函數和結果選擇器函數。

**範例**:

```csharp
var studentsByGrade = students.GroupBy(
    s => s.Grade,
    (grade, sts) => new { Grade = grade, Students = sts.Select(s => s.Name) }
);

foreach (var group in studentsByGrade)
{
    Console.WriteLine($"Grade {group.Grade}: [{string.Join(", ", group.Students)}]");
}

// 預期輸出:
// Grade 90: [Alice, Charlie]
// Grade 80: [Bob]
```

#### 多載 4: `GroupBy<TSource, TKey, TElement, TResult>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TElement>, Func<TKey, IEnumerable<TElement>, TResult>)`

**使用說明**: 使用鍵值選擇器、元素選擇器和結果選擇器。

**範例**:

```csharp
var groupedStudents = students.GroupBy(
    s => s.Grade,
    s => s.Name,
    (grade, names) => new { Grade = grade, StudentNames = names }
);

foreach (var group in groupedStudents)
{
    Console.WriteLine($"Grade {group.Grade}: [{string.Join(", ", group.StudentNames)}]");
}

// 預期輸出:
// Grade 90: [Alice, Charlie]
// Grade 80: [Bob]
```

## 聚合（Aggregation）

### `Count`: 計算序列中的元素數量

#### 基本 `Count` 用法

**方法**: `Count<TSource>(IEnumerable<TSource>)`  
**使用說明**: 計算序列中的元素數量。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
var count = numbers.Count();

Console.WriteLine($"Element count: {count}");

// 預期輸出:
// Element count: 9
```

#### `Count` 方法的多載

**多載**: `Count<TSource>(IEnumerable<TSource>, Func<TSource, bool>)`  
**使用說明**: 計算滿足指定條件的序列中元素的數量。

**範例**:

```csharp
var evenCount = numbers.Count(n => n % 2 == 0);

Console.WriteLine($"Even numbers count: {evenCount}");

// 預期輸出:
// Even numbers count: 4
```

### `Sum`: 計算序列中數字的總和

#### 基本 `Sum` 用法

**方法**: `Sum(IEnumerable<int>)` (以及針對 `float`, `double`, `decimal`, `long` 的類似多載)  
**使用說明**: 計算數字序列的總和。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var sum = numbers.Sum();

Console.WriteLine($"Sum: {sum}");

// 預期輸出:
// Sum: 15
```

#### `Sum` 方法的多載

**多載**: `Sum<TSource>(IEnumerable<TSource>, Func<TSource, int>)` (以及針對 `float`, `double`, `decimal`, `long` 的類似多載)  
**使用說明**: 對於一個非數字的序列，使用一個轉換函數來指定如何從每個元素中提取數字，然後計算這些數字的總和。

**範例**:
假設我們有一個學生列表，每個學生有他們的分數，我們想計算這些分數的總和。

```csharp
var students = new List<Student>
{
    new Student { Name = "Alice", Grade = 90 },
    new Student { Name = "Bob", Grade = 80 },
    new Student { Name = "Charlie", Grade = 85 }
};

var totalGrade = students.Sum(s => s.Grade);

Console.WriteLine($"Total grade: {totalGrade}");

// 預期輸出:
// Total grade: 255
```

### `Average`: 計算序列中數字的平均值

#### 基本 `Average` 用法

**方法**: `Average(IEnumerable<int>)`（同樣適用於 `float`, `double`, `decimal`, `long` 等數字類型的序列）  
**使用說明**: 計算數字序列的平均值。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var average = numbers.Average();

Console.WriteLine($"Average: {average}");

// 預期輸出:
// Average: 3
```

#### `Average` 方法的多載

**多載**: `Average<TSource>(IEnumerable<TSource>, Func<TSource, int>)`（同樣適用於將 `TSource` 轉換為 `float`, `double`, `decimal`, `long` 的函數）  
**使用說明**: 對於一個非數字的序列，使用一個轉換函數來指定如何從每個元素中提取數字，然後計算這些數字的平均值。

**範例**:
假設我們有一個學生列表，每個學生有他們的分數，我們想計算這些分數的平均值。

```csharp
var students = new List<Student>
{
    new Student { Name = "Alice", Grade = 90 },
    new Student { Name = "Bob", Grade = 80 },
    new Student { Name = "Charlie", Grade = 85 }
};

var averageGrade = students.Average(s => s.Grade);

Console.WriteLine($"Average grade: {averageGrade}");

// 預期輸出:
// Average grade: 85
```

### `Min`: 找出序列中的最小值

#### 基本 `Min` 用法

**方法**: `Min(IEnumerable<int>)`（同樣適用於 `float`, `double`, `decimal`, `long` 等數字類型的序列）  
**使用說明**: 從數字序列中找出最小值。

**範例**:

```csharp
var numbers = new List<int> { 5, 4, 1, 2, 3 };
var min = numbers.Min();

Console.WriteLine($"Minimum value: {min}");

// 預期輸出:
// Minimum value: 1
```

#### `Min` 方法的多載

**多載**: `Min<TSource>(IEnumerable<TSource>, Func<TSource, int>)`（同樣適用於將 `TSource` 轉換為 `float`, `double`, `decimal`, `long` 的函數）  
**使用說明**: 對於一個非數字的序列，使用一個轉換函數來指定如何從每個元素中提取數字，然後找出這些數字中的最小值。

**範例**:
假設我們有一個學生列表，每個學生有他們的分數，我們想找出這些分數中的最小值。

```csharp
var students = new List<Student>
{
    new Student { Name = "Alice", Grade = 90 },
    new Student { Name = "Bob", Grade = 80 },
    new Student { Name = "Charlie", Grade = 85 }
};

var minGrade = students.Min(s => s.Grade);

Console.WriteLine($"Minimum grade: {minGrade}");

// 預期輸出:
// Minimum grade: 80
```

### `Max`: 找出序列中的最大值

#### 基本 `Max` 用法

**方法**: `Max(IEnumerable<int>)`（同樣適用於 `float`, `double`, `decimal`, `long` 等數字類型的序列）  
**使用說明**: 從數字序列中找出最大值。

**範例**:

```csharp
var numbers = new List<int> { 1, 3, 5, 7, 9 };
var max = numbers.Max();

Console.WriteLine($"Maximum value: {max}");

// 預期輸出:
// Maximum value: 9
```

#### `Max` 方法的多載

**多載**: `Max<TSource>(IEnumerable<TSource>, Func<TSource, int>)`（同樣適用於將 `TSource` 轉換為 `float`, `double`, `decimal`, `long` 的函數）  
**使用說明**: 對於一個非數字的序列，使用一個轉換函數來指定如何從每個元素中提取數字，然後找出這些數字中的最大值。

**範例**:
假設我們有一個學生列表，每個學生有他們的分數，我們想找出這些分數中的最大值。

```csharp
var students = new List<Student>
{
    new Student { Name = "Alice", Grade = 90 },
    new Student { Name = "Bob", Grade = 80 },
    new Student { Name = "Charlie", Grade = 85 }
};

var maxGrade = students.Max(s => s.Grade);

Console.WriteLine($"Maximum grade: {maxGrade}");

// 預期輸出:
// Maximum grade: 90
```

### `Aggregate`: 通過累加器函數對序列的元素進行累積

#### 基本 `Aggregate` 用法

**方法**: `Aggregate<TSource>(IEnumerable<TSource>, Func<TSource, TSource, TSource>)`  
**使用說明**: 使用累加器函數對序列的元素進行累積。累加器函數在每次迭代中運用於當前累積值和序列的下一個元素。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var sum = numbers.Aggregate((acc, n) => acc + n);

Console.WriteLine($"Sum: {sum}");

// 預期輸出:
// Sum: 15
```

這個範例中，`Aggregate` 用於計算數字序列的總和。初始累積值設為序列的第一個元素，然後將每個後續元素依次加到累積值上。

#### `Aggregate` 方法的多載

**多載**: `Aggregate<TSource, TAccumulate>(IEnumerable<TSource>, TAccumulate, Func<TAccumulate, TSource, TAccumulate>)`  
**使用說明**: 這個多載允許您指定一個初始累積值，並使用一個函數定義如何將序列中的每個元素與累積值結合。

**範例**:
計算所有數字的乘積。

```csharp
var product = numbers.Aggregate(1, (acc, n) => acc * n);

Console.WriteLine($"Product: {product}");

// 預期輸出:
// Product: 120
```

在這個範例中，我們使用 `Aggregate` 方法來計算數字序列的乘積。初始累

積值設為 1（這是乘法的恆等元素），然後將序列中的每個數字依次乘以累積值。

#### 進階 `Aggregate` 使用

**多載**: `Aggregate<TSource, TAccumulate, TResult>(IEnumerable<TSource>, TAccumulate, Func<TAccumulate, TSource, TAccumulate>, Func<TAccumulate, TResult>)`  
**使用說明**: 這個多載允許您在累積過程結束後將累積結果轉換為另一種類型。

**範例**:
計算數字序列的總和，並將結果轉換為字符串格式。

```csharp
var sumString = numbers.Aggregate(0, (acc, n) => acc + n, acc => $"Sum: {acc}");

Console.WriteLine(sumString);

// 預期輸出:
// Sum: 15
```

在這個範例中，我們首先計算數字序列的總和，然後使用最後一個函數將數字轉換為字符串。這顯示了 `Aggregate` 方法不僅可以用於累積計算，還可以在計算完成後進行類型轉換或進一步處理。這種方法特別有用於更複雜的數據處理和轉換場景。

## 集合操作（Set）

### `Distinct`: 移除序列中的重複元素

#### 基本 `Distinct` 用法

**方法**: `Distinct<TSource>(IEnumerable<TSource>)`  
**使用說明**: 移除序列中的重複元素，返回一個不包含任何重複元素的新序列。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 2, 3, 3, 4, 5, 5 };
var distinctNumbers = numbers.Distinct();

Console.WriteLine($"Distinct: {string.Join(", ", distinctNumbers)}");

// 預期輸出:
// Distinct: 1, 2, 3, 4, 5
```

#### `Distinct` 方法的多載

**多載**: `Distinct<TSource>(IEnumerable<TSource>, IEqualityComparer<TSource>)`  
**使用說明**: 使用自定義比較器移除序列中的重複元素。

**範例**:
使用自定義比較器移除重複元素（假設 `CustomComparer` 實現了 `IEqualityComparer<int>`）。

```csharp
var customComparer = new CustomComparer(); // 假設 CustomComparer 是一個實現了 IEqualityComparer<int> 的類
var distinctWithComparer = numbers.Distinct(customComparer);

// 使用 customComparer 來判斷元素是否重複
```

### `Union`: 聯合兩個序列

#### 基本 `Union` 用法

**方法**: `Union<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)`  
**使用說明**: 聯合兩個序列，返回一個包含兩個序列中所有不重複元素的新序列。

**範例**:

```csharp
var first = new List<int> { 1, 2, 3 };
var second = new List<int> { 3, 4, 5 };
var union = first.Union(second);

Console.WriteLine($"Union: {string.Join(", ", union)}");

// 預期輸出:
// Union: 1, 2, 3, 4, 5
```

#### `Union` 方法的多載

**多載**: `Union<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, IEqualityComparer<TSource>)`  
**使用說明**: 使用自定義比較器聯合兩個序列。

**範例**:
使用自定義比較器

聯合兩個序列（假設 `CustomComparer` 實現了 `IEqualityComparer<int>`）。

```csharp
var unionWithComparer = first.Union(second, customComparer);

Console.WriteLine($"Union with custom comparer: {string.Join(", ", unionWithComparer)}");

// 使用 customComparer 來聯合序列
```

### `Intersect`: 求兩個序列的交集

#### 基本 `Intersect` 用法

**方法**: `Intersect<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)`  
**使用說明**: 求兩個序列的交集，返回包含兩個序列中共有的元素的新序列。

**範例**:

```csharp
var intersect = first.Intersect(second);

Console.WriteLine($"Intersect: {string.Join(", ", intersect)}");

// 預期輸出:
// Intersect: 3
```

#### `Intersect` 方法的多載

**多載**: `Intersect<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, IEqualityComparer<TSource>)`  
**使用說明**: 使用自定義比較器求兩個序列的交集。

**範例**:
使用自定義比較器求交集。

```csharp
var intersectWithComparer = first.Intersect(second, customComparer);

Console.WriteLine($"Intersect with custom comparer: {string.Join(", ", intersectWithComparer)}");

// 使用 customComparer 來求交集
```

### `Except`: 從一個序列中排除另一個序列中的元素

#### 基本 `Except` 用法

**方法**: `Except<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)`  
**使用說明**: 從第一個序列中排除在第二個序列中出現的元素，返回一個新序列。

**範例**:

```csharp
var except = first.Except(second);

Console.WriteLine($"Except: {string.Join(", ", except)}");

// 預期輸出:
// Except: 1, 2
```

#### `Except` 方法的多載

**多載**: `Except<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, IEqualityComparer<TSource>)`  
**使用說明**: 使用自定義比較器從一個序列中排除另一個序列中的元素。

**範例**:
使用自定義比較器進行排除操作。

```csharp
var exceptWithComparer = first.Except(second, customComparer);

Console.WriteLine($"Except with custom comparer: {string.Join(", ", exceptWithComparer)}");

// 使用 customComparer 來進行排除操作
```

### `IEqualityComparer<T>` 實現範例  

創建一個自定義的比較器來比較字符串，忽略大小寫

#### `CaseInsensitiveEqualityComparer` 的實現

實現一個 `IEqualityComparer<string>` 來比較字符串，但在比較時不考慮大小寫。

```csharp
public class CaseInsensitiveEqualityComparer : IEqualityComparer<string>
{
    public bool Equals(string x, string y)
    {
        // 使用 String.Equals 方法比較兩個字符串，忽略大小寫
        return string.Equals(x, y, StringComparison.OrdinalIgnoreCase);
    }

    public int GetHashCode(string obj)
    {
        // 如果 obj 為 null，則返回 0，否則返回 obj 的小寫形式的哈希碼
        return obj == null ? 0 : obj.ToLowerInvariant().GetHashCode();
    }
}
```

#### 使用 `CaseInsensitiveEqualityComparer`

假設我們有一個字符串序列，並希望使用我們的 `CaseInsensitiveEqualityComparer` 來移除重複的字符串，忽略大小寫。

```csharp
var words = new List<string> { "apple", "Apple", "banana", "Banana", "orange" };
var distinctWords = words.Distinct(new CaseInsensitiveEqualityComparer());

Console.WriteLine($"Distinct words (case-insensitive): {string.Join(", ", distinctWords)}");

// 預期輸出:
// Distinct words (case-insensitive): apple, banana, orange
```

## 元素操作（Element）

### `First`: 返回序列中的第一個元素

#### 基本 `First` 用法

**方法**: `First<TSource>(IEnumerable<TSource>)`  
**使用說明**: 返回序列中的第一個元素。如果序列為空，則拋出 `InvalidOperationException`。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var firstNumber = numbers.First();

Console.WriteLine($"First number: {firstNumber}");

// 預期輸出:
// First number: 1
```

#### `First` 方法的多載

**多載**: `First<TSource>(IEnumerable<TSource>, Func<TSource, bool>)`  
**使用說明**: 返回序列中滿足指定條件的第一個元素。如果沒有元素滿足條件，則拋出 `InvalidOperationException`。

**範例**:
返回序列中第一個大於 3 的數字。

```csharp
var firstLargerThanThree = numbers.First(n => n > 3);

Console.WriteLine($"First number greater than 3: {firstLargerThanThree}");

// 預期輸出:
// First number greater than 3: 4
```

### `FirstOrDefault`: 返回序列中的第一個元素，如果序列為空，則返回預設值

#### 基本 `FirstOrDefault` 用法

**方法**: `FirstOrDefault<TSource>(IEnumerable<TSource>)`  
**使用說明**: 返回序列中的第一個元素。如果序列為空，則返回該類型的預設值（對於引用類型為 `null`，對於值類型為 `0` 或 `false` 等）。

**範例**:

```csharp
var emptyList = new List<int>();
var firstOrDefaulNumber = emptyList.FirstOrDefault();

Console.WriteLine($"First or default number: {firstOrDefaulNumber}");

// 預期輸出:
// First or default number: 0
```

#### `FirstOrDefault` 方法的多載

**多載**: `FirstOrDefault<TSource>(IEnumerable<TSource>, Func<TSource, bool>)`  
**使用說明**: 返回序列中滿足指定條件的第一個元素。如果沒有元素滿足條件或序列為空，則返回該類型的預設值。

**範例**:
返回序列中第一個大於 10 的數字，如果沒有，則返回預設值。

```csharp
var firstLargerThanTenOrDefault = numbers.FirstOrDefault(n => n > 10);

Console.WriteLine($"First number greater than 10 or default: {firstLargerThanTenOrDefault}");

// 預期輸出:
// First number greater than 10 or default: 0
```

### `Last`: 返回序列中的最後一個元素

#### 基本 `Last` 用法

**方法**: `Last<TSource>(IEnumerable<TSource>)`  
**使用說明**: 返回序列中的最後一個元素。如果序列為空，則拋出 `InvalidOperationException`。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var lastNumber = numbers.Last();

Console.WriteLine($"Last number: {lastNumber}");

// 預期輸出:
// Last number: 5
```

#### `Last` 方法的多載

**多載**: `Last<TSource>(IEnumerable<TSource>, Func<TSource, bool>)`  
**使用說明**: 返回序列中滿足指定條件的最後一個元素。如果沒有元素滿足條件，則拋出 `InvalidOperationException`。

**範例**:
返回序列中小於 4 的最後一個數字。

```csharp
var lastLessThanFour = numbers.Last(n => n < 4);

Console.WriteLine($"Last number less than 4: {lastLessThanFour}");

// 預期輸出:
// Last number less than 4: 3
```

### `LastOrDefault`: 返回序列中的最後一個元素，如果序列為空，則返回預設值

#### 基本 `LastOrDefault` 用法

**方法**: `LastOrDefault<TSource>(IEnumerable<TSource>)`  
**使用說明**: 返回序列中的最後一個元素。如果序列為空，則返回該類型的預設值（對於引用類型為 `null`，對於值類型為 `0` 或 `false` 等）。

**範例**:

```csharp
var emptyList = new List<int>();
var lastOrDefaultNumber = emptyList.LastOrDefault();

Console.WriteLine($"Last or default number: {lastOrDefaultNumber}");

// 預期輸出:
// Last or default number: 0
```

#### `LastOrDefault` 方法的多載

**多載**: `LastOrDefault<TSource>(IEnumerable<TSource>, Func<TSource, bool>)`  
**使用說明**: 返回序列中滿足指定條件的最後一個元素。如果沒有元素滿足條件或序列為空，則返回該類型的預設值。

**範例**:
返回序列中大於 10 的最後一個數字，如果沒有，則返回預設值。

```csharp
var lastLargerThanTenOrDefault = numbers.LastOrDefault(n => n > 10);

Console.WriteLine($"Last number greater than 10 or default: {lastLargerThanTenOrDefault}");

// 預期輸出:
// Last number greater than 10 or default: 0
```

### `Single`: 返回序列中的唯一元素

#### 基本 `Single` 用法

**方法**: `Single<TSource>(IEnumerable<TSource>)`  
**使用說明**: 返回序列中的唯一元素。如果序列中沒有元素或者有多個元素，則拋出 `InvalidOperationException`。

**範例**:

```csharp
var singleElementList = new List<int> { 4 };
var singleNumber = singleElementList.Single();

Console.WriteLine($"Single number: {singleNumber}");

// 預期輸出:
// Single number: 4
```

#### `Single` 方法的多載

**多載**: `Single<TSource>(IEnumerable<TSource>, Func<TSource, bool>)`  
**使用說明**: 返回序列中滿足指定條件的唯一元素。如果沒有元素滿足條件或者有多個元素滿足條件，則拋出 `InvalidOperationException`。

**範例**:
返回序列中唯一的一個大於 3 的數字。

```csharp
var numbers = new List<int> { 1, 2, 3, 4 };
var singleLargerThanThree = numbers.Single(n => n > 3);

Console.WriteLine($"Single number greater than 3: {singleLargerThanThree}");

// 預期輸出:
// Single number greater than 3: 4
```

### `SingleOrDefault`: 返回序列中的唯一元素

#### 基本 `SingleOrDefault` 用法

**方法**: `SingleOrDefault<TSource>(IEnumerable<TSource>)`  
**使用說明**: 返回序列中的唯一元素。如果序列為空，則返回預設值；如果序列中有多個元素，則拋出 `InvalidOperationException`。

**範例**:

```csharp
var emptyList = new List<int>();
var singleOrDefaultNumber = emptyList.SingleOrDefault();

Console.WriteLine($"Single or default number: {singleOrDefaultNumber}");

// 預期輸出:
// Single or default number: 0
```

#### `SingleOrDefault` 方法的多載

**多載**: `SingleOrDefault<TSource>(IEnumerable<TSource>, Func<TSource, bool>)`  
**使用說明**: 返回序列中滿足指定條件的唯一元素。如果序列為空，則返回預設值；如果序列中有多個元素滿足條件，則拋出 `InvalidOperationException`。

**範例**:
返回序列中唯一的一個等於 3 的數字，如果沒有，則返回預設值。

```csharp
var numbers = new List<int> { 1, 2, 3, 4 };
var singleOrDefaulEqualToThree = numbers.SingleOrDefault(n => n == 3);

Console.WriteLine($"Single or default number equal to 3: {singleOrDefaulEqualToThree}");

// 預期輸出:
// Single or default number equal to 3: 3
```

### `ElementAt`: 返回序列中指定索引處的元素

#### 基本 `ElementAt` 用法

**方法**: `ElementAt<TSource>(IEnumerable<TSource>, int)`  
**使用說明**: 返回序列中指定索引處的元素。如果索引超出序列的範圍，則拋出 `ArgumentOutOfRangeException`。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var elementAtIndexTwo = numbers.ElementAt(2);

Console.WriteLine($"Element at index 2: {elementAtIndexTwo}");

// 預期輸出:
// Element at index 2: 3
```

### `ElementAtOrDefault`: 返回序列中指定索引處的元素，如果索引超出範圍，則返回預設值

#### 基本 `ElementAtOrDefault` 用法

**方法**: `ElementAtOrDefault<TSource>(IEnumerable<TSource>, int)`  
**使用說明**: 返回序列中指定索引處的元素。如果指定的索引超出序列的範圍，則返回該類型的預設值（對於引用類型為 `null`，對於值類型為 `0` 或 `false` 等）。

**範例**:

```csharp
var elementAtIndexTen = numbers.ElementAtOrDefault(10);

Console.WriteLine($"Element at index 10 or default: {elementAtIndexTen}");

// 預期輸出:
// Element at index 10 or default: 0
```

## 分割（Partitioning）

### `Take`: 從序列的開始返回指定數量的元素

#### 基本 `Take` 用法

**方法**: `Take<TSource>(IEnumerable<TSource>, int)`  
**使用說明**: 從序列的開始返回指定數量的元素。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
var firstThree = numbers.Take(3);

Console.WriteLine("First 3 elements:");
foreach (var n in firstThree)
{
    Console.WriteLine(n);
}

// 預期輸出:
// First 3 elements:
// 1
// 2
// 3
```
### `Skip`: 跳過序列的開始部分，返回剩下的元素

#### 基本 `Skip` 用法

**方法**: `Skip<TSource>(IEnumerable<TSource>, int)`  
**使用說明**: 跳過序列的開始指定數量的元素，返回剩下的元素。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
var skipFirstThree = numbers.Skip(3);

Console.WriteLine("Elements after skipping first 3:");
foreach (var n in skipFirstThree)
{
    Console.WriteLine(n);
}

// 輸出:
// Elements after skipping first 3:
// 4
// 5
// 6
// 7
// 8
// 9
```

### `TakeWhile`: 返回序列中符合條件的連續元素

#### 基本 `TakeWhile` 用法

**方法**: `TakeWhile<TSource>(IEnumerable<TSource>, Func<TSource, bool>)`  
**使用說明**: 返回序列中從開始連續符合指定條件的元素。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
var takeWhileLessThanFive = numbers.TakeWhile(n => n < 5);

Console.WriteLine("Elements less than 5:");
foreach (var n in takeWhileLessThanFive)
{
    Console.WriteLine(n);
}

// 預期輸出:
// Elements less than 5:
// 1
// 2
// 3
// 4
```
#### `TakeWhile` 方法的多載

允許在條件函數中使用元素的索引。

**多載**: `TakeWhile<TSource>(IEnumerable<TSource>, Func<TSource, int, bool>)`  
**使用說明**: 根據元素及其在序列中的索引來判斷是否繼續取得元素。

**範例**:

```csharp
var takeWhileIndexLessThanPosition = numbers.TakeWhile((n, index) => index < n);

Console.WriteLine("Elements with index less than value:");
foreach (var n in takeWhileIndexLessThanPosition)
{
    Console.WriteLine(n);
}

// 預期輸出:
// Elements with index less than value:
// 1
// 2
```

### `SkipWhile`: 跳過序列中符合條件的連續元素，然後返回餘下的元素

#### 基本 `SkipWhile` 用法

**方法**: `SkipWhile<TSource>(IEnumerable<TSource>, Func<TSource, bool>)`  
**使用說明**: 跳過序列中從開始連續符合指定條件的元素，然後返回餘下的元素。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
var skipWhileLessThanFive = numbers.SkipWhile(n => n < 5);

Console.WriteLine("Elements after skipping elements less than 5:");
foreach (var n in skipWhileLessThanFive)
{
    Console.WriteLine(n);
}

// 預期輸出:
// Elements after skipping elements less than 5:
// 5
// 6
// 7
// 8
// 9
```

#### `SkipWhile` 方法的多載

允許在條件函數中使用元素的索引。

**多載**: `SkipWhile<TSource>(IEnumerable<TSource>, Func<TSource, int, bool>)`  
**使用說明**: 根據元素及其在序列中的索引來判斷從何處開始停止跳過元素。

**範例**:

```csharp
var skipWhileIndexLessThanPosition = numbers.SkipWhile((n, index) => index < n);

Console.WriteLine("Elements after skipping elements with index less than value:");
foreach (var n in skipWhileIndexLessThanPosition)
{
    Console.WriteLine(n);
}

// 預期輸出:
// Elements after skipping elements with index less than value:
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
```

## 轉換（Conversion）

### `ToArray`: 將序列轉換為數組

#### 基本 `ToArray` 用法

**方法**: `ToArray<TSource>(IEnumerable<TSource>)`  
**使用說明**: 將 IEnumerable<T> 的元素轉換為新的數組。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
var array = numbers.ToArray();

Console.WriteLine("Array elements:");
foreach (var n in array)
{
    Console.WriteLine(n);
}

// 預期輸出:
// Array elements:
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
```

### `ToList`: 將序列轉換為列表

#### 基本 `ToList` 用法

**方法**: `ToList<TSource>(IEnumerable<TSource>)`  
**使用說明**: 將 `IEnumerable<T>` 的元素轉換為新的列表（List<T>）。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
var list = numbers.ToList();

Console.WriteLine("List elements:");
foreach (var n in list)
{
    Console.WriteLine(n);
}

// 預期輸出:
// List elements:
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
```

### `OfType`: 根據指定的類型過濾序列的元素

#### 基本 `OfType` 用法

**方法**: `OfType<TResult>(IEnumerable)`  
**使用說明**: 從一個非泛型 `IEnumerable` 序列中過濾出指定類型 `TResult` 的元素，並返回這些元素的泛型 `IEnumerable<TResult>` 集合。

**範例**:

```csharp
var objects = new List<object> { "Hello", 1, "World", 2.5, 3, "!", 4.0 };
var strings = objects.OfType<string>();

Console.WriteLine("String elements:");
foreach (var str in strings)
{
    Console.WriteLine(str);
}

// 預期輸出:
// String elements:
// Hello
// World
// !
```

### `ToDictionary`: 將序列元素轉換為字典

#### 基本 `ToDictionary<TSource, TKey>` 用法

**方法**: `ToDictionary<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>)`  
**使用說明**: 將 `IEnumerable<T>` 的元素轉換為 `Dictionary<TKey, TSource>`，其中每個鍵由指定的鍵選擇器函數產生。

**範例**:

```csharp
var people = new List<Person>
{
    new Person { Name = "Alice", Age = 30 },
    new Person { Name = "Bob", Age = 25 }
};

var dictionary = people.ToDictionary(p => p.Name);

Console.WriteLine("Dictionary contents:");
foreach (var kvp in dictionary)
{
    Console.WriteLine($"Key: {kvp.Key}, Value: {kvp.Value.Age}");
}

// 預期輸出:
// Dictionary contents:
// Key: Alice, Value: 30
// Key: Bob, Value: 25
```

#### `ToDictionary<TSource, TKey, TValue>` 多載

**方法**: `ToDictionary<TSource, TKey, TValue>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TValue>)`  
**使用說明**: 將 `IEnumerable<T>` 的元素轉換為 `Dictionary<TKey, TValue>`，其中每個鍵和值由指定的鍵選擇器和值選擇器函數產生。

**範例**:

```csharp
var dictionary = people.ToDictionary(p => p.Name, p => p.Age);

Console.WriteLine("Dictionary contents:");
foreach (var kvp in dictionary)
{
    Console.WriteLine($"Key: {kvp.Key}, Value: {kvp.Value}");
}

// 預期輸出:
// Dictionary contents:
// Key: Alice, Value: 30
// Key: Bob, Value: 25
```

#### `ToDictionary<TSource, TKey, TValue>` 附加相等比較器的多載

**方法**: `ToDictionary<TSource, TKey, TValue>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TValue>, IEqualityComparer<TKey>)`  
**使用說明**: 除了轉換為 `Dictionary<TKey, TValue>` 外，還可以指定一個用於比較鍵的相等比較器。

**範例**:

```csharp
var comparer = StringComparer.OrdinalIgnoreCase;
var dictionary = people.ToDictionary(p => p.Name, p => p.Age, comparer);

Console.WriteLine("Dictionary contents with case-insensitive keys:");
foreach (var kvp in dictionary)
{
    Console.WriteLine($"Key: {kvp.Key}, Value: {kvp.Value}");
}

// 預期輸出:
// Dictionary contents with case-insensitive keys:
// Key: Alice, Value: 30
// Key: Bob, Value: 25
```

## 量化（Quantifiers）

- `Any`: 檢查序列中是否有任何元素滿足條件。
- `All`: 檢查序列中的所有元素是否都滿足條件。

## 生成操作（Generation）

### `Empty`: 返回空的序列

#### 基本 `Empty` 用法

**方法**: `Empty<TResult>()`  
**使用說明**: 返回指定類型 `TResult` 的空序列。

`Empty` 方法是一個靜態方法，屬於 `System.Linq.Enumerable` 類。這個方法非常有用，當你需要一個不含任何元素的序列作為查詢的一部分或者當作方法的返回值時。

**範例**:

```csharp
var emptyIntegers = Enumerable.Empty<int>();

Console.WriteLine("Number of elements in the sequence: " + emptyIntegers.Count());

// 預期輸出:
// Number of elements in the sequence: 0
```

### `Range`: 生成一個包含指定範圍內連續整數的序列

#### 基本 `Range` 用法

**方法**: `Range(int start, int count)`  
**使用說明**: 生成一個包含從 `start` 開始的 `count` 個連續整數的序列。

`Range` 方法是 `System.Linq.Enumerable` 類中的一個靜態方法，用於快速生成一系列連續的整數。這個方法在需要一定範圍內的數據時非常有用，例如用於測試、生成索引等。

**範例**:

```csharp
var range = Enumerable.Range(1, 10);

Console.WriteLine("Range of integers:");
foreach (var n in range)
{
    Console.WriteLine(n);
}

// 預期輸出:
// Range of integers:
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
// 10
```

### `Repeat`: 生成一個包含重複值的序列

#### 基本 `Repeat` 用法

**方法**: `Repeat<T>(T element, int count)`  
**使用說明**: 生成一個序列，其中包含指定次數的重複 `element`。

`Repeat` 方法是 `System.Linq.Enumerable` 類中的一個靜態方法，用於創建一個包含特定值重複多次的序列。需要大量重複數據的測試或初始設置時非常有用。

**範例**:

```csharp
var repeated = Enumerable.Repeat("Hello", 5);

Console.WriteLine("Repeated elements:");
foreach (var item in repeated)
{
    Console.WriteLine(item);
}

// 預期輸出:
// Repeated elements:
// Hello
// Hello
// Hello
// Hello
// Hello
```

## 異常處理（Exception Handling）

- `Catch`: 當源序列引發異常時提供替代序列。
- `Finally`: 無論序列是否引發異常，都要執行某些最終操作。

## 延遲執行（Deferred Execution）

- `AsEnumerable`: 將任何類型的 `IQueryable` 轉換為 `IEnumerable`，以進行本地查詢操作。
- `AsQueryable`: 將任何類型的 `IEnumerable` 轉換為 `IQueryable`。

## 連接（Joining）

## 預設值（Default Values）

### `DefaultIfEmpty`: 如果序列為空，則返回一個包含單個預設值的序列

#### 基本 `DefaultIfEmpty` 用法

**方法**: `DefaultIfEmpty<TSource>(IEnumerable<TSource>)`  
**使用說明**: 當 `IEnumerable<T>` 序列為空時，此方法返回一個包含單個預設值（對於引用類型為 null，對於值類型為 0）的序列。如果序列不為空，則返回原序列。

`DefaultIfEmpty` 方法在處理可能為空的序列時非常有用，特別是在連接查詢或其它需要至少一個元素的情況下。

**範例**:

```csharp
var emptyIntegers = new List<int>();
var defaultList = emptyIntegers.DefaultIfEmpty();

Console.WriteLine("Default list contents:");
foreach (var n in defaultList)
{
    Console.WriteLine(n);
}

// 預期輸出:
// Default list contents:
// 0
```

#### `DefaultIfEmpty<TSource>(IEnumerable<TSource>, TSource)` 多載

**方法**: `DefaultIfEmpty<TSource>(IEnumerable<TSource>, TSource defaultValue)`  
**使用說明**: 當序列為空時，此方法返回一個包含指定的 `defaultValue` 的序列。如果序列不為空，則返回原序列。

**範例**:

```csharp
var defaultListWithCustomValue = emptyIntegers.DefaultIfEmpty(-1);

Console.WriteLine("Default list with custom value:");
foreach (var n in defaultListWithCustomValue)
{
    Console.WriteLine(n);
}

// 預期輸出:
// Default list with custom value:
// -1
```

### `Join`: 通過匹配鍵值將兩個序列的元素組合在一起

#### 基本 `Join` 用法

**方法**: `Join<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, TInner, TResult>)`  
**使用說明**: 這個方法通過對兩個序列（一個外部序列和一個內部序列）中的元素執行內部連接操作來組合它們。它匹配兩個序列中具有相同鍵的元素。

`Join` 方法類似於 SQL 中的 JOIN 操作。它可以用於將兩個不同數據集的相關數據聯合起來。

**範例**:

```csharp
var employees = new List<Employee>
{
    new Employee { ID = 1, Name = "Alice" },
    new Employee { ID = 2, Name = "Bob" }
};

var departments = new List<Department>
{
    new Department { ID = 1, Name = "HR" },
    new Department { ID = 2, Name = "IT" }
};

var employeeDepartments = employees.Join(departments,
                                         e => e.ID,
                                         d => d.ID,
                                         (e, d) => new { e.Name, Department = d.Name });

Console.WriteLine("Employee and their departments:");
foreach (var item in employeeDepartments)
{
    Console.WriteLine($"{item.Name} works in {item.Department}");
}

// 預期輸出:
// Employee and their departments:
// Alice works in HR
// Bob works in IT
```

#### 使用 `Join` 聯接三個表

定義三個簡單的類別和相應的集合資料：

```csharp
public class Employee
{
    public int ID { get; set; }
    public string Name { get; set; }
    public int DepartmentID { get; set; }
    public int PositionID { get; set; }
}

public class Department
{
    public int ID { get; set; }
    public string Name { get; set; }
}

public class Position
{
    public int ID { get; set; }
    public string Title { get; set; }
}

var employees = new List<Employee>
{
    new Employee { ID = 1, Name = "Alice", DepartmentID = 2, PositionID = 1 },
    new Employee { ID = 2, Name = "Bob", DepartmentID = 1, PositionID = 2 }
};

var departments = new List<Department>
{
    new Department { ID = 1, Name = "HR" },
    new Department { ID = 2, Name = "IT" }
};

var positions = new List<Position>
{
    new Position { ID = 1, Title = "Manager" },
    new Position { ID = 2, Title = "Developer" }
};
```

使用 `Join` 方法來聯接這三個集合：

```csharp
var query = employees.Join(departments, 
                           e => e.DepartmentID, 
                           d => d.ID, 
                           (e, d) => new { e, d })
                     .Join(positions, 
                           ed => ed.e.PositionID, 
                           p => p.ID, 
                           (ed, p) => new { EmployeeName = ed.e.Name, Department = ed.d.Name, Position = p.Title });

foreach (var item in query)
{
    Console.WriteLine($"Employee: {item.EmployeeName}, Department: {item.Department}, Position: {item.Position}");
}

// 預期輸出:
// Employee: Alice, Department: IT, Position: Manager
// Employee: Bob, Department: HR, Position: Developer
```
### `GroupJoin`: 基於匹配鍵值，將兩個序列的元素與它們的匹配組合在一起

#### 基本 `GroupJoin` 用法

**方法**: `GroupJoin<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter>, IEnumerable<TInner>, Func<TOuter, TKey>, Func<TInner, TKey>, Func<TOuter, IEnumerable<TInner>, TResult>)`  
**使用說明**: `GroupJoin` 方法對兩個序列進行分組連接操作。它將外部序列 (`TOuter`) 的每個元素與內部序列 (`TInner`) 中匹配的元素序列組合起來，基於一個共同的鍵 (`TKey`)。

這個方法適合於那些需要將一個集合中的元素與另一個集合中相關聯的多個元素組合在一起的情況。在某種程度上類似於 SQL 中的左外連接(Left Join)。

**範例**:

```csharp
var employees = new List<Employee>
{
    new Employee { ID = 1, Name = "Alice" },
    new Employee { ID = 2, Name = "Bob" }
};

var tasks = new List<Task>
{
    new Task { EmployeeID = 1, Description = "Report" },
    new Task { EmployeeID = 2, Description = "Presentation" },
    new Task { EmployeeID = 1, Description = "Meeting" }
};

var employeeTasks = employees.GroupJoin(tasks,
                                        e => e.ID,
                                        t => t.EmployeeID,
                                        (e, ts) => new { EmployeeName = e.Name, Tasks = ts.Select(t => t.Description) });

foreach (var et in employeeTasks)
{
    Console.WriteLine($"{et.EmployeeName} has the following tasks: {String.Join(", ", et.Tasks)}");
}

// 預期輸出:
// Alice has the following tasks: Report, Meeting
// Bob has the following tasks: Presentation
```

#### 範例：使用`GroupJoin` 實現左連接(Left Join)

假設我們有兩個類：`Employee` 和 `Department`，以及相應的集合。我們希望將員工與他們所屬的部門相連接，即使某些員工沒有分配部門。

定義類別和集合：

```csharp
public class Employee
{
    public int ID { get; set; }
    public string Name { get; set; }
    public int? DepartmentID { get; set; }
}

public class Department
{
    public int ID { get; set; }
    public string Name { get; set; }
}

var employees = new List<Employee>
{
    new Employee { ID = 1, Name = "Alice", DepartmentID = 1 },
    new Employee { ID = 2, Name = "Bob", DepartmentID = 2 },
    new Employee { ID = 3, Name = "Charlie" } // 沒有部門
};

var departments = new List<Department>
{
    new Department { ID = 1, Name = "HR" },
    new Department { ID = 2, Name = "IT" }
};
```

使用 `GroupJoin` 進行左連接：

```csharp
var query = employees.GroupJoin(departments, 
                                e => e.DepartmentID, 
                                d => d.ID, 
                                (e, d) => new { e.Name, Department = d.FirstOrDefault()?.Name ?? "No Department" });

foreach (var item in query)
{
    Console.WriteLine($"{item.Name} works in {item.Department}");
}

// 預期輸出:
// Alice works in HR
// Bob works in IT
// Charlie works in No Department
```

#### 範例：使用 `DefaultIfEmpty` 實現左外連接

仍然使用前面的 `Employee` 和 `Department` 類別及相應的集合：

```csharp
var employees = new List<Employee>
{
    new Employee { ID = 1, Name = "Alice", DepartmentID = 1 },
    new Employee { ID = 2, Name = "Bob", DepartmentID = 2 },
    new Employee { ID = 3, Name = "Charlie" } // 沒有部門
};

var departments = new List<Department>
{
    new Department { ID = 1, Name = "HR" },
    new Department { ID = 2, Name = "IT" }
};
```

進行左連接：

```csharp
var employeeDepartments = from e in employees
                          join d in departments 
                          on e.DepartmentID equals d.ID into deptGroup
                          from dept in deptGroup.DefaultIfEmpty()
                          select new 
                          {
                              EmployeeName = e.Name,
                              DepartmentName = dept != null ? dept.Name : "No Department"
                          };

foreach (var item in employeeDepartments)
{
    Console.WriteLine($"{item.EmployeeName} works in {item.DepartmentName}");
}

// 預期輸出:
// Alice works in HR
// Bob works in IT
// Charlie works in No Department
```
```csharp
var employeeDepartments = employees.GroupJoin(departments, 
                                               e => e.DepartmentID, 
                                               d => d.ID, 
                                               (e, d) => new { e, d })
                                    .SelectMany(
                                        ed => ed.d.DefaultIfEmpty(),
                                        (ed, dept) => new 
                                        {
                                            EmployeeName = ed.e.Name,
                                            DepartmentName = dept != null ? dept.Name : "No Department"
                                        });

foreach (var item in employeeDepartments)
{
    Console.WriteLine($"{item.EmployeeName} works in {item.DepartmentName}");
}

// 預期輸出:
// Alice works in HR
// Bob works in IT
// Charlie works in No Department

```

## 組合（Concatenation）

- `Concat`: 連接兩個序列。

## 分隔（Paging）

- `SkipLast`: 跳過序列末尾的指定數量的元素。
- `TakeLast`: 從序列末尾取出指定數量的元素。

## 異步操作（Asynchronous）

- `ToListAsync`, `ToArrayAsync`, `ToDictionaryAsync` 等：用於異步操作的方法，主要用於 Entity Framework Core。

## 比較（Comparisons）

- `SequenceEqual`: 確定兩個序列是否按相同的順序具有相同的元素。

## 鑄造（Casting）

- `Cast`: 將 `IEnumerable` 的元素轉換為指定的類型。

## 分組結果（Grouping Results）

- `ToLookup`: 根據鍵值將序列元素分組並創建一個 `Lookup`（類似於一個一對多的字典）。

## 字串操作（String-specific）

- `Contains`: 檢查序列中是否包含特定元素。
- `StartsWith`, `EndsWith`: 這些方法通常用於字符串序列，檢查元素是否以特定的子串開始或結束。

## 反射操作

- `AsParallel`, `AsOrdered`, `AsUnordered`: 這些方法用於 PLINQ（Parallel LINQ），支持對數據的並行處理。

## 自訂操作

- `Let`: 在查詢中引入新的識別符，以存儲中間結果或進行複雜的子查詢。
