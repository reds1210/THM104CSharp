# 02語法

## 過濾（Filtering）

### `Where`: 基於條件過濾序列  
  
基本用法: 根據條件過濾序列。

```C#
var numbers = new List<int> { 1, 6, 2, 9, 5 };
var filteredNumbers = numbers.Where(n => n > 5);
```

多載用法: 使用元素的索引作為過濾條件。

```C#
var filteredWithIndex = numbers.Where((num, index) => index % 2 == 0);
```

## 排序（Ordering）

### `OrderBy`: 按指定鍵值升序排序  

基本用法:

```C#
var students = new List<Student> { /* ... */ };
var sortedStudents = students.OrderBy(s => s.Age);
```

---------

### `OrderByDescending`: 按指定鍵值降序排序

基本用法:

```C#
var descendingSortedStudents = students.OrderByDescending(s => s.Age);
```

---------

### `ThenBy`: 在前一個排序條件之後進行二級排序（升序）

基本用法:

```C#
var sortedByName = students.OrderBy(s => s.LastName).ThenBy(s => s.FirstName);
```

---------

### `ThenByDescending`: 在前一個排序條件之後進行二級排序（降序）

基本用法:

```C#
var sortedByNameDesc = students.OrderBy(s => s.LastName).ThenByDescending(s => s.FirstName);
```

---------

### `Reverse`: 反轉序列中元素的順序

基本用法:

```C#
var numbers = new List<int> { 1, 2, 3, 4, 5 };
numbers.Reverse();
```

## 投影（Projection）

### `Select`: 投影每個元素到一個新形式

#### 1. 基本投影

轉換集合中的元素到一個新的形式。

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var squares = numbers.Select(x => x * x); // 將每個數字映射到其平方
```

#### 2. 投影到新類型

創建一個新的物件類型。

```csharp
var students = new List<Student> { /* ... */ };
var studentDTOs = students.Select(s => new StudentDTO { Name = s.Name, Age = s.Age });
```

#### 3. 使用索引

在Lambda中使用元素的索引。

```csharp
var words = new List<string> { "apple", "banana", "cherry" };
var indexedWords = words.Select((word, index) => new { Index = index, Word = word });
```

#### 4. 條件性投影

根據條件改變投影的結果。

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var labels = numbers.Select(n => n % 2 == 0 ? "Even" : "Odd");
```

#### 5. 複雜類型的投影

從複雜對象中選擇多個屬性。

```csharp
var orders = new List<Order> { /* ... */ };
var orderInfos = orders.Select(o => new { o.OrderId, o.Customer.Name, o.TotalAmount });
```

#### 6. 鏈接投影

將 `Select` 與其他 LINQ 方法結合使用。

```csharp
var students = new List<Student> { /* ... */ };
var topStudentNames = students.Where(s => s.Grade > 90).Select(s => s.Name);
```

---------

### `SelectMany`: 將序列的序列平坦化為一個序列

特別有用於處理嵌套集合或多級結構的數據

#### 1. 基本使用 - 扁平化嵌套集合

當每個元素本身是一個集合時，將這些集合合併成一個單一的序列。

```csharp
var listOfLists = new List<List<int>>
{
    new List<int> { 1, 2, 3 },
    new List<int> { 4, 5, 6 },
    new List<int> { 7, 8, 9 }
};

var flattened = listOfLists.SelectMany(x => x);
// 結果: 1, 2, 3, 4, 5, 6, 7, 8, 9
```

#### 2. 投影並扁平化

對集合的每個元素進行處理，並將結果扁平化。

```csharp
public class Course
{
    public string CourseName { get; set; }
}

public class Student
{
    public string Name { get; set; }
    public List<Course> Courses { get; set; }
}
var students = new List<Student>
{
    new Student {
        Name = "Alice",
        Courses = new List<Course> {
            new Course { CourseName = "Math" },
            new Course { CourseName = "English" }
        }
    },
    new Student {
        Name = "Bob",
        Courses = new List<Course> {
            new Course { CourseName = "Science" },
            new Course { CourseName = "History" }
        }
    }
};
var allCourses = students.SelectMany(s => s.Courses).Select(c => c.CourseName).ToList();

foreach (var course in allCourses)
{
    Console.WriteLine(course);
} 
// 扁平化學生的課程列表，得到所有學生的所有課程。
```

#### 3. 結合多個集合

允許對來自原始元素和其相關集合的元素進行投影。

```csharp
var chars = new List<char> { 'A', 'B', 'C' };
var numbers = new List<int> { 1, 2, 3 };

var combinations = chars.SelectMany(c => numbers, (c, n) => $"{c}{n}");
// 結果: "A1", "A2", "A3", "B1", "B2", "B3", "C1", "C2", "C3"
```

```csharp
var listOfPairs = new List<(int, List<string>)>
{
    (1, new List<string> { "a", "b" }),
    (2, new List<string> { "c", "d" })
};

var pairFlattened = listOfPairs.SelectMany(
    pair => pair.Item2, 
    (pair, item) => $"{pair.Item1}{item}"
);
// 結果: "1a", "1b", "2c", "2d"
```

#### 4. 使用索引

函數接受兩個參數：元素和其在原始序列中的索引。

```csharp
var listOfLists = new List<List<int>>
{
    new List<int> { 1, 2 },
    new List<int> { 3, 4 }
};

var indexedFlattened = listOfLists.SelectMany((subList, index) => subList.Select(item => new { index, item }));
// 結果: { index = 0, item = 1 }, { index = 0, item = 2 }, { index = 1, item = 3 }, { index = 1, item = 4 }
```

#### 5. 扁平化複雜數據結構

用於更複雜的數據結構，如多層嵌套集合。

定義 `School`、`Class` 和 `Student` 類：

```csharp
public class School
{
    public string Name { get; set; }
    public List<Class> Classes { get; set; }
}

public class Class
{
    public string ClassName { get; set; }
    public List<Student> Students { get; set; }
}

public class Student
{
    public string Name { get; set; }
}
```

然後，我們創建一個包含學校、班級和學生的列表：

```csharp
var schools = new List<School>
{
    new School
    {
        Name = "School A",
        Classes = new List<Class>
        {
            new Class
            {
                ClassName = "Class 1A",
                Students = new List<Student>
                {
                    new Student { Name = "Alice" },
                    new Student { Name = "Bob" }
                }
            },
            new Class
            {
                ClassName = "Class 1B",
                Students = new List<Student>
                {
                    new Student { Name = "Charlie" },
                    new Student { Name = "David" }
                }
            }
        }
    },
    new School
    {
        Name = "School B",
        Classes = new List<Class>
        {
            new Class
            {
                ClassName = "Class 2A",
                Students = new List<Student>
                {
                    new Student { Name = "Emma" },
                    new Student { Name = "Frank" }
                }
            }
        }
    }
};
```

最後，使用 `SelectMany` 提取所有學校的所有班級的所有學生：

```csharp
var allStudents = schools.SelectMany(school => school.Classes.SelectMany(class => class.Students)).ToList();

foreach (var student in allStudents)
{
    Console.WriteLine(student.Name);
}
```

## 分組（Grouping）

### `GroupBy`: 根據鍵值將序列元素分組

#### 多載 1: `GroupBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>)`

**使用說明**: 根據單一鍵值選擇器函數進行分組。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
var groupedByParity = numbers.GroupBy(n => n % 2 == 0 ? "Even" : "Odd");

foreach (var group in groupedByParity)
{
    Console.WriteLine($"{group.Key}: [{string.Join(", ", group)}]");
}

// 預期輸出:
// Odd: [1, 3, 5, 7, 9]
// Even: [2, 4, 6, 8]
```

#### 多載 2: `GroupBy<TSource, TKey, TElement>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TElement>)`

**使用說明**: 使用鍵值選擇器函數和元素選擇器函數。

**範例**:

```csharp
var students = new List<Student>
{
    new Student { Name = "Alice", Grade = 90 },
    new Student { Name = "Bob", Grade = 80 },
    new Student { Name = "Charlie", Grade = 90 }
};

var groupedByGrade = students.GroupBy(s => s.Grade, s => s.Name);

foreach (var group in groupedByGrade)
{
    Console.WriteLine($"Grade {group.Key}: [{string.Join(", ", group)}]");
}

// 預期輸出:
// Grade 90: [Alice, Charlie]
// Grade 80: [Bob]
```

#### 多載 3: `GroupBy<TSource, TKey, TResult>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TKey, IEnumerable<TSource>, TResult>)`

**使用說明**: 使用鍵值選擇器函數和結果選擇器函數。

**範例**:

```csharp
var studentsByGrade = students.GroupBy(
    s => s.Grade,
    (grade, sts) => new { Grade = grade, Students = sts.Select(s => s.Name) }
);

foreach (var group in studentsByGrade)
{
    Console.WriteLine($"Grade {group.Grade}: [{string.Join(", ", group.Students)}]");
}

// 預期輸出:
// Grade 90: [Alice, Charlie]
// Grade 80: [Bob]
```

#### 多載 4: `GroupBy<TSource, TKey, TElement, TResult>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TSource, TElement>, Func<TKey, IEnumerable<TElement>, TResult>)`

**使用說明**: 使用鍵值選擇器、元素選擇器和結果選擇器。

**範例**:

```csharp
var groupedStudents = students.GroupBy(
    s => s.Grade,
    s => s.Name,
    (grade, names) => new { Grade = grade, StudentNames = names }
);

foreach (var group in groupedStudents)
{
    Console.WriteLine($"Grade {group.Grade}: [{string.Join(", ", group.StudentNames)}]");
}

// 預期輸出:
// Grade 90: [Alice, Charlie]
// Grade 80: [Bob]
```

## 聚合（Aggregation）

### `Count`: 計算序列中的元素數量

#### 基本 `Count` 用法

**方法**: `Count<TSource>(IEnumerable<TSource>)`  
**使用說明**: 計算序列中的元素數量。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
var count = numbers.Count();

Console.WriteLine($"Element count: {count}");

// 預期輸出:
// Element count: 9
```

#### `Count` 方法的多載

**多載**: `Count<TSource>(IEnumerable<TSource>, Func<TSource, bool>)`  
**使用說明**: 計算滿足指定條件的序列中元素的數量。

**範例**:

```csharp
var evenCount = numbers.Count(n => n % 2 == 0);

Console.WriteLine($"Even numbers count: {evenCount}");

// 預期輸出:
// Even numbers count: 4
```

### `Sum`: 計算序列中數字的總和

#### 基本 `Sum` 用法

**方法**: `Sum(IEnumerable<int>)` (以及針對 `float`, `double`, `decimal`, `long` 的類似多載)  
**使用說明**: 計算數字序列的總和。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var sum = numbers.Sum();

Console.WriteLine($"Sum: {sum}");

// 預期輸出:
// Sum: 15
```

#### `Sum` 方法的多載

**多載**: `Sum<TSource>(IEnumerable<TSource>, Func<TSource, int>)` (以及針對 `float`, `double`, `decimal`, `long` 的類似多載)  
**使用說明**: 對於一個非數字的序列，使用一個轉換函數來指定如何從每個元素中提取數字，然後計算這些數字的總和。

**範例**:
假設我們有一個學生列表，每個學生有他們的分數，我們想計算這些分數的總和。

```csharp
var students = new List<Student>
{
    new Student { Name = "Alice", Grade = 90 },
    new Student { Name = "Bob", Grade = 80 },
    new Student { Name = "Charlie", Grade = 85 }
};

var totalGrade = students.Sum(s => s.Grade);

Console.WriteLine($"Total grade: {totalGrade}");

// 預期輸出:
// Total grade: 255
```

### `Average`: 計算序列中數字的平均值

#### 基本 `Average` 用法

**方法**: `Average(IEnumerable<int>)`（同樣適用於 `float`, `double`, `decimal`, `long` 等數字類型的序列）  
**使用說明**: 計算數字序列的平均值。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var average = numbers.Average();

Console.WriteLine($"Average: {average}");

// 預期輸出:
// Average: 3
```

#### `Average` 方法的多載

**多載**: `Average<TSource>(IEnumerable<TSource>, Func<TSource, int>)`（同樣適用於將 `TSource` 轉換為 `float`, `double`, `decimal`, `long` 的函數）  
**使用說明**: 對於一個非數字的序列，使用一個轉換函數來指定如何從每個元素中提取數字，然後計算這些數字的平均值。

**範例**:
假設我們有一個學生列表，每個學生有他們的分數，我們想計算這些分數的平均值。

```csharp
var students = new List<Student>
{
    new Student { Name = "Alice", Grade = 90 },
    new Student { Name = "Bob", Grade = 80 },
    new Student { Name = "Charlie", Grade = 85 }
};

var averageGrade = students.Average(s => s.Grade);

Console.WriteLine($"Average grade: {averageGrade}");

// 預期輸出:
// Average grade: 85
```

### `Min`: 找出序列中的最小值

#### 基本 `Min` 用法

**方法**: `Min(IEnumerable<int>)`（同樣適用於 `float`, `double`, `decimal`, `long` 等數字類型的序列）  
**使用說明**: 從數字序列中找出最小值。

**範例**:

```csharp
var numbers = new List<int> { 5, 4, 1, 2, 3 };
var min = numbers.Min();

Console.WriteLine($"Minimum value: {min}");

// 預期輸出:
// Minimum value: 1
```

#### `Min` 方法的多載

**多載**: `Min<TSource>(IEnumerable<TSource>, Func<TSource, int>)`（同樣適用於將 `TSource` 轉換為 `float`, `double`, `decimal`, `long` 的函數）  
**使用說明**: 對於一個非數字的序列，使用一個轉換函數來指定如何從每個元素中提取數字，然後找出這些數字中的最小值。

**範例**:
假設我們有一個學生列表，每個學生有他們的分數，我們想找出這些分數中的最小值。

```csharp
var students = new List<Student>
{
    new Student { Name = "Alice", Grade = 90 },
    new Student { Name = "Bob", Grade = 80 },
    new Student { Name = "Charlie", Grade = 85 }
};

var minGrade = students.Min(s => s.Grade);

Console.WriteLine($"Minimum grade: {minGrade}");

// 預期輸出:
// Minimum grade: 80
```

### `Max`: 找出序列中的最大值

#### 基本 `Max` 用法

**方法**: `Max(IEnumerable<int>)`（同樣適用於 `float`, `double`, `decimal`, `long` 等數字類型的序列）  
**使用說明**: 從數字序列中找出最大值。

**範例**:

```csharp
var numbers = new List<int> { 1, 3, 5, 7, 9 };
var max = numbers.Max();

Console.WriteLine($"Maximum value: {max}");

// 預期輸出:
// Maximum value: 9
```

#### `Max` 方法的多載

**多載**: `Max<TSource>(IEnumerable<TSource>, Func<TSource, int>)`（同樣適用於將 `TSource` 轉換為 `float`, `double`, `decimal`, `long` 的函數）  
**使用說明**: 對於一個非數字的序列，使用一個轉換函數來指定如何從每個元素中提取數字，然後找出這些數字中的最大值。

**範例**:
假設我們有一個學生列表，每個學生有他們的分數，我們想找出這些分數中的最大值。

```csharp
var students = new List<Student>
{
    new Student { Name = "Alice", Grade = 90 },
    new Student { Name = "Bob", Grade = 80 },
    new Student { Name = "Charlie", Grade = 85 }
};

var maxGrade = students.Max(s => s.Grade);

Console.WriteLine($"Maximum grade: {maxGrade}");

// 預期輸出:
// Maximum grade: 90
```

### `Aggregate`: 通過累加器函數對序列的元素進行累積

#### 基本 `Aggregate` 用法

**方法**: `Aggregate<TSource>(IEnumerable<TSource>, Func<TSource, TSource, TSource>)`  
**使用說明**: 使用累加器函數對序列的元素進行累積。累加器函數在每次迭代中運用於當前累積值和序列的下一個元素。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var sum = numbers.Aggregate((acc, n) => acc + n);

Console.WriteLine($"Sum: {sum}");

// 預期輸出:
// Sum: 15
```

這個範例中，`Aggregate` 用於計算數字序列的總和。初始累積值設為序列的第一個元素，然後將每個後續元素依次加到累積值上。

#### `Aggregate` 方法的多載

**多載**: `Aggregate<TSource, TAccumulate>(IEnumerable<TSource>, TAccumulate, Func<TAccumulate, TSource, TAccumulate>)`  
**使用說明**: 這個多載允許您指定一個初始累積值，並使用一個函數定義如何將序列中的每個元素與累積值結合。

**範例**:
計算所有數字的乘積。

```csharp
var product = numbers.Aggregate(1, (acc, n) => acc * n);

Console.WriteLine($"Product: {product}");

// 預期輸出:
// Product: 120
```

在這個範例中，我們使用 `Aggregate` 方法來計算數字序列的乘積。初始累

積值設為 1（這是乘法的恆等元素），然後將序列中的每個數字依次乘以累積值。

#### 進階 `Aggregate` 使用

**多載**: `Aggregate<TSource, TAccumulate, TResult>(IEnumerable<TSource>, TAccumulate, Func<TAccumulate, TSource, TAccumulate>, Func<TAccumulate, TResult>)`  
**使用說明**: 這個多載允許您在累積過程結束後將累積結果轉換為另一種類型。

**範例**:
計算數字序列的總和，並將結果轉換為字符串格式。

```csharp
var sumString = numbers.Aggregate(0, (acc, n) => acc + n, acc => $"Sum: {acc}");

Console.WriteLine(sumString);

// 預期輸出:
// Sum: 15
```

在這個範例中，我們首先計算數字序列的總和，然後使用最後一個函數將數字轉換為字符串。這顯示了 `Aggregate` 方法不僅可以用於累積計算，還可以在計算完成後進行類型轉換或進一步處理。這種方法特別有用於更複雜的數據處理和轉換場景。

## 集合操作（Set）

### `Distinct`: 移除序列中的重複元素

#### 基本 `Distinct` 用法

**方法**: `Distinct<TSource>(IEnumerable<TSource>)`  
**使用說明**: 移除序列中的重複元素，返回一個不包含任何重複元素的新序列。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 2, 3, 3, 4, 5, 5 };
var distinctNumbers = numbers.Distinct();

Console.WriteLine($"Distinct: {string.Join(", ", distinctNumbers)}");

// 預期輸出:
// Distinct: 1, 2, 3, 4, 5
```

#### `Distinct` 方法的多載

**多載**: `Distinct<TSource>(IEnumerable<TSource>, IEqualityComparer<TSource>)`  
**使用說明**: 使用自定義比較器移除序列中的重複元素。

**範例**:
使用自定義比較器移除重複元素（假設 `CustomComparer` 實現了 `IEqualityComparer<int>`）。

```csharp
var customComparer = new CustomComparer(); // 假設 CustomComparer 是一個實現了 IEqualityComparer<int> 的類
var distinctWithComparer = numbers.Distinct(customComparer);

// 使用 customComparer 來判斷元素是否重複
```

### `Union`: 聯合兩個序列

#### 基本 `Union` 用法

**方法**: `Union<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)`  
**使用說明**: 聯合兩個序列，返回一個包含兩個序列中所有不重複元素的新序列。

**範例**:

```csharp
var first = new List<int> { 1, 2, 3 };
var second = new List<int> { 3, 4, 5 };
var union = first.Union(second);

Console.WriteLine($"Union: {string.Join(", ", union)}");

// 預期輸出:
// Union: 1, 2, 3, 4, 5
```

#### `Union` 方法的多載

**多載**: `Union<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, IEqualityComparer<TSource>)`  
**使用說明**: 使用自定義比較器聯合兩個序列。

**範例**:
使用自定義比較器

聯合兩個序列（假設 `CustomComparer` 實現了 `IEqualityComparer<int>`）。

```csharp
var unionWithComparer = first.Union(second, customComparer);

Console.WriteLine($"Union with custom comparer: {string.Join(", ", unionWithComparer)}");

// 使用 customComparer 來聯合序列
```

### `Intersect`: 求兩個序列的交集

#### 基本 `Intersect` 用法

**方法**: `Intersect<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)`  
**使用說明**: 求兩個序列的交集，返回包含兩個序列中共有的元素的新序列。

**範例**:

```csharp
var intersect = first.Intersect(second);

Console.WriteLine($"Intersect: {string.Join(", ", intersect)}");

// 預期輸出:
// Intersect: 3
```

#### `Intersect` 方法的多載

**多載**: `Intersect<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, IEqualityComparer<TSource>)`  
**使用說明**: 使用自定義比較器求兩個序列的交集。

**範例**:
使用自定義比較器求交集。

```csharp
var intersectWithComparer = first.Intersect(second, customComparer);

Console.WriteLine($"Intersect with custom comparer: {string.Join(", ", intersectWithComparer)}");

// 使用 customComparer 來求交集
```

### `Except`: 從一個序列中排除另一個序列中的元素

#### 基本 `Except` 用法

**方法**: `Except<TSource>(IEnumerable<TSource>, IEnumerable<TSource>)`  
**使用說明**: 從第一個序列中排除在第二個序列中出現的元素，返回一個新序列。

**範例**:

```csharp
var except = first.Except(second);

Console.WriteLine($"Except: {string.Join(", ", except)}");

// 預期輸出:
// Except: 1, 2
```

#### `Except` 方法的多載

**多載**: `Except<TSource>(IEnumerable<TSource>, IEnumerable<TSource>, IEqualityComparer<TSource>)`  
**使用說明**: 使用自定義比較器從一個序列中排除另一個序列中的元素。

**範例**:
使用自定義比較器進行排除操作。

```csharp
var exceptWithComparer = first.Except(second, customComparer);

Console.WriteLine($"Except with custom comparer: {string.Join(", ", exceptWithComparer)}");

// 使用 customComparer 來進行排除操作
```

### `IEqualityComparer<T>` 實現範例  

創建一個自定義的比較器來比較字符串，忽略大小寫

#### `CaseInsensitiveEqualityComparer` 的實現

實現一個 `IEqualityComparer<string>` 來比較字符串，但在比較時不考慮大小寫。

```csharp
public class CaseInsensitiveEqualityComparer : IEqualityComparer<string>
{
    public bool Equals(string x, string y)
    {
        // 使用 String.Equals 方法比較兩個字符串，忽略大小寫
        return string.Equals(x, y, StringComparison.OrdinalIgnoreCase);
    }

    public int GetHashCode(string obj)
    {
        // 如果 obj 為 null，則返回 0，否則返回 obj 的小寫形式的哈希碼
        return obj == null ? 0 : obj.ToLowerInvariant().GetHashCode();
    }
}
```

#### 使用 `CaseInsensitiveEqualityComparer`

假設我們有一個字符串序列，並希望使用我們的 `CaseInsensitiveEqualityComparer` 來移除重複的字符串，忽略大小寫。

```csharp
var words = new List<string> { "apple", "Apple", "banana", "Banana", "orange" };
var distinctWords = words.Distinct(new CaseInsensitiveEqualityComparer());

Console.WriteLine($"Distinct words (case-insensitive): {string.Join(", ", distinctWords)}");

// 預期輸出:
// Distinct words (case-insensitive): apple, banana, orange
```

## 元素操作（Element）

### `First`: 返回序列中的第一個元素

#### 基本 `First` 用法

**方法**: `First<TSource>(IEnumerable<TSource>)`  
**使用說明**: 返回序列中的第一個元素。如果序列為空，則拋出 `InvalidOperationException`。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var firstNumber = numbers.First();

Console.WriteLine($"First number: {firstNumber}");

// 預期輸出:
// First number: 1
```

#### `First` 方法的多載

**多載**: `First<TSource>(IEnumerable<TSource>, Func<TSource, bool>)`  
**使用說明**: 返回序列中滿足指定條件的第一個元素。如果沒有元素滿足條件，則拋出 `InvalidOperationException`。

**範例**:
返回序列中第一個大於 3 的數字。

```csharp
var firstLargerThanThree = numbers.First(n => n > 3);

Console.WriteLine($"First number greater than 3: {firstLargerThanThree}");

// 預期輸出:
// First number greater than 3: 4
```

### `FirstOrDefault`: 返回序列中的第一個元素，如果序列為空，則返回預設值

#### 基本 `FirstOrDefault` 用法

**方法**: `FirstOrDefault<TSource>(IEnumerable<TSource>)`  
**使用說明**: 返回序列中的第一個元素。如果序列為空，則返回該類型的預設值（對於引用類型為 `null`，對於值類型為 `0` 或 `false` 等）。

**範例**:

```csharp
var emptyList = new List<int>();
var firstOrDefaulNumber = emptyList.FirstOrDefault();

Console.WriteLine($"First or default number: {firstOrDefaulNumber}");

// 預期輸出:
// First or default number: 0
```

#### `FirstOrDefault` 方法的多載

**多載**: `FirstOrDefault<TSource>(IEnumerable<TSource>, Func<TSource, bool>)`  
**使用說明**: 返回序列中滿足指定條件的第一個元素。如果沒有元素滿足條件或序列為空，則返回該類型的預設值。

**範例**:
返回序列中第一個大於 10 的數字，如果沒有，則返回預設值。

```csharp
var firstLargerThanTenOrDefault = numbers.FirstOrDefault(n => n > 10);

Console.WriteLine($"First number greater than 10 or default: {firstLargerThanTenOrDefault}");

// 預期輸出:
// First number greater than 10 or default: 0
```

### `Last`: 返回序列中的最後一個元素

#### 基本 `Last` 用法

**方法**: `Last<TSource>(IEnumerable<TSource>)`  
**使用說明**: 返回序列中的最後一個元素。如果序列為空，則拋出 `InvalidOperationException`。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var lastNumber = numbers.Last();

Console.WriteLine($"Last number: {lastNumber}");

// 預期輸出:
// Last number: 5
```

#### `Last` 方法的多載

**多載**: `Last<TSource>(IEnumerable<TSource>, Func<TSource, bool>)`  
**使用說明**: 返回序列中滿足指定條件的最後一個元素。如果沒有元素滿足條件，則拋出 `InvalidOperationException`。

**範例**:
返回序列中小於 4 的最後一個數字。

```csharp
var lastLessThanFour = numbers.Last(n => n < 4);

Console.WriteLine($"Last number less than 4: {lastLessThanFour}");

// 預期輸出:
// Last number less than 4: 3
```

### `LastOrDefault`: 返回序列中的最後一個元素，如果序列為空，則返回預設值

#### 基本 `LastOrDefault` 用法

**方法**: `LastOrDefault<TSource>(IEnumerable<TSource>)`  
**使用說明**: 返回序列中的最後一個元素。如果序列為空，則返回該類型的預設值（對於引用類型為 `null`，對於值類型為 `0` 或 `false` 等）。

**範例**:

```csharp
var emptyList = new List<int>();
var lastOrDefaultNumber = emptyList.LastOrDefault();

Console.WriteLine($"Last or default number: {lastOrDefaultNumber}");

// 預期輸出:
// Last or default number: 0
```

#### `LastOrDefault` 方法的多載

**多載**: `LastOrDefault<TSource>(IEnumerable<TSource>, Func<TSource, bool>)`  
**使用說明**: 返回序列中滿足指定條件的最後一個元素。如果沒有元素滿足條件或序列為空，則返回該類型的預設值。

**範例**:
返回序列中大於 10 的最後一個數字，如果沒有，則返回預設值。

```csharp
var lastLargerThanTenOrDefault = numbers.LastOrDefault(n => n > 10);

Console.WriteLine($"Last number greater than 10 or default: {lastLargerThanTenOrDefault}");

// 預期輸出:
// Last number greater than 10 or default: 0
```

### `Single`: 返回序列中的唯一元素

#### 基本 `Single` 用法

**方法**: `Single<TSource>(IEnumerable<TSource>)`  
**使用說明**: 返回序列中的唯一元素。如果序列中沒有元素或者有多個元素，則拋出 `InvalidOperationException`。

**範例**:

```csharp
var singleElementList = new List<int> { 4 };
var singleNumber = singleElementList.Single();

Console.WriteLine($"Single number: {singleNumber}");

// 預期輸出:
// Single number: 4
```

#### `Single` 方法的多載

**多載**: `Single<TSource>(IEnumerable<TSource>, Func<TSource, bool>)`  
**使用說明**: 返回序列中滿足指定條件的唯一元素。如果沒有元素滿足條件或者有多個元素滿足條件，則拋出 `InvalidOperationException`。

**範例**:
返回序列中唯一的一個大於 3 的數字。

```csharp
var numbers = new List<int> { 1, 2, 3, 4 };
var singleLargerThanThree = numbers.Single(n => n > 3);

Console.WriteLine($"Single number greater than 3: {singleLargerThanThree}");

// 預期輸出:
// Single number greater than 3: 4
```

### `SingleOrDefault`: 返回序列中的唯一元素

#### 基本 `SingleOrDefault` 用法

**方法**: `SingleOrDefault<TSource>(IEnumerable<TSource>)`  
**使用說明**: 返回序列中的唯一元素。如果序列為空，則返回預設值；如果序列中有多個元素，則拋出 `InvalidOperationException`。

**範例**:

```csharp
var emptyList = new List<int>();
var singleOrDefaultNumber = emptyList.SingleOrDefault();

Console.WriteLine($"Single or default number: {singleOrDefaultNumber}");

// 預期輸出:
// Single or default number: 0
```

#### `SingleOrDefault` 方法的多載

**多載**: `SingleOrDefault<TSource>(IEnumerable<TSource>, Func<TSource, bool>)`  
**使用說明**: 返回序列中滿足指定條件的唯一元素。如果序列為空，則返回預設值；如果序列中有多個元素滿足條件，則拋出 `InvalidOperationException`。

**範例**:
返回序列中唯一的一個等於 3 的數字，如果沒有，則返回預設值。

```csharp
var numbers = new List<int> { 1, 2, 3, 4 };
var singleOrDefaulEqualToThree = numbers.SingleOrDefault(n => n == 3);

Console.WriteLine($"Single or default number equal to 3: {singleOrDefaulEqualToThree}");

// 預期輸出:
// Single or default number equal to 3: 3
```

### `ElementAt`: 返回序列中指定索引處的元素

#### 基本 `ElementAt` 用法

**方法**: `ElementAt<TSource>(IEnumerable<TSource>, int)`  
**使用說明**: 返回序列中指定索引處的元素。如果索引超出序列的範圍，則拋出 `ArgumentOutOfRangeException`。

**範例**:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5 };
var elementAtIndexTwo = numbers.ElementAt(2);

Console.WriteLine($"Element at index 2: {elementAtIndexTwo}");

// 預期輸出:
// Element at index 2: 3
```

### `ElementAtOrDefault`: 返回序列中指定索引處的元素，如果索引超出範圍，則返回預設值

#### 基本 `ElementAtOrDefault` 用法

**方法**: `ElementAtOrDefault<TSource>(IEnumerable<TSource>, int)`  
**使用說明**: 返回序列中指定索引處的元素。如果指定的索引超出序列的範圍，則返回該類型的預設值（對於引用類型為 `null`，對於值類型為 `0` 或 `false` 等）。

**範例**:

```csharp
var elementAtIndexTen = numbers.ElementAtOrDefault(10);

Console.WriteLine($"Element at index 10 or default: {elementAtIndexTen}");

// 預期輸出:
// Element at index 10 or default: 0
```

## 分割（Partitioning）

- `Take`: 從序列的開始返回指定數量的元素。
- `Skip`: 跳過序列的開始部分，返回餘下的元素。
- `TakeWhile`: 返回序列中符合條件的連續元素。
- `SkipWhile`: 跳過序列中符合條件的連續元素，然後返回餘下的元素。

## 轉換（Conversion）

- `ToArray`: 將序列轉換為數組。
- `ToList`: 將序列轉換為列表。
- `ToDictionary`: 將序列元素轉換為字典。
- `OfType`: 根據指定的類型過濾序列的元素。

## 量化（Quantifiers）

- `Any`: 檢查序列中是否有任何元素滿足條件。
- `All`: 檢查序列中的所有元素是否都滿足條件。

## 生成操作（Generation）

- `Empty`: 返回空的序列。
- `Range`: 生成一個包含指定範圍內連續整數的序列。
- `Repeat`: 生成一個包含重複值的序列。

## 異常處理（Exception Handling）

- `Catch`: 當源序列引發異常時提供替代序列。
- `Finally`: 無論序列是否引發異常，都要執行某些最終操作。

## 延遲執行（Deferred Execution）

- `AsEnumerable`: 將任何類型的 `IQueryable` 轉換為 `IEnumerable`，以進行本地查詢操作。
- `AsQueryable`: 將任何類型的 `IEnumerable` 轉換為 `IQueryable`。

## 連接（Joining）

- `Join`: 通過匹配鍵值將兩個序列的元素組合在一起。
- `GroupJoin`: 基於匹配鍵值，將兩個序列的元素與它們的匹配組合在一起。

## 預設值（Default Values）

- `DefaultIfEmpty`: 如果序列為空，則返回一個包含單個預設值的序列。

## 組合（Concatenation）

- `Concat`: 連接兩個序列。

## 分隔（Paging）

- `SkipLast`: 跳過序列末尾的指定數量的元素。
- `TakeLast`: 從序列末尾取出指定數量的元素。

## 異步操作（Asynchronous）

- `ToListAsync`, `ToArrayAsync`, `ToDictionaryAsync` 等：用於異步操作的方法，主要用於 Entity Framework Core。

## 比較（Comparisons）

- `SequenceEqual`: 確定兩個序列是否按相同的順序具有相同的元素。

## 鑄造（Casting）

- `Cast`: 將 `IEnumerable` 的元素轉換為指定的類型。

## 分組結果（Grouping Results）

- `ToLookup`: 根據鍵值將序列元素分組並創建一個 `Lookup`（類似於一個一對多的字典）。

## 字串操作（String-specific）

- `Contains`: 檢查序列中是否包含特定元素。
- `StartsWith`, `EndsWith`: 這些方法通常用於字符串序列，檢查元素是否以特定的子串開始或結束。

## 反射操作

- `AsParallel`, `AsOrdered`, `AsUnordered`: 這些方法用於 PLINQ（Parallel LINQ），支持對數據的並行處理。

## 自訂操作

- `Let`: 在查詢中引入新的識別符，以存儲中間結果或進行複雜的子查詢。
