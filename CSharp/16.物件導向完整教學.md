# C# 物件導向程式設計：給初學者的溫柔指南
## —— 從零打造「Daily Buddy 日常互助小助理」

> **寫給妳的話：**
> 哈囉！歡迎來到物件導向（Object-Oriented Programming, OOP）的世界。
> 聽到「物件導向」這個詞，妳可能會覺得聽起來很硬、很難懂。別擔心，真的很硬🤣( 說笑的拉。
> 
> 在還沒學會之前妳寫程式可能像是在寫一張長長的條列式清單像是流水帳；
> 
> 學會物件導向後，妳會像是在「佈置房間」或「分配角色」，把複雜的事情交給不同的「小幫手」去處理。
> 
> 我們會用一個溫暖的小專案 **「Daily Buddy」** 貫穿這份講義。想像妳正在為妳和好朋友（小逸與小悅）寫一個互相提醒、紀錄生活的小程式。
> 
> 慢慢來，我們一步一步走。

---

## 📍 學習地圖與節奏

這份講義內容非常豐富，建議妳依照以下節奏學習，不要急著一次看完：

*   **Part 1：基礎篇（Chapter 1 - 4）**
    *   學會如何創造「物件」，並學會保護資料、管理清單。
    *   **專案進度**：可以傳送訊息、新增待辦事項。
*   **Part 2：結構篇（Chapter 5 - 8）**
    *   學會共用資料、處理錯誤、以及不用重複造輪子的「繼承」技巧。
    *   **專案進度**：加入心情記錄、運動打卡。
*   **Part 3：進階篇（Chapter 9 - 13）** <span style="color:green">← 妳目前在這裡</span>
    *   學會讓程式更有彈性的「多型」與「介面」，還有最後的完整專案組裝。
    *   **專案進度**：加入提醒功能、每日摘要報告、完整版程式。

---

## 📖 目錄

*   [Chapter 1. 類別與物件：程式裡的「模具」與「成品」](#chapter-1-類別與物件程式裡的模具與成品)
*   [Chapter 2. 封裝：保護妳的小秘密](#chapter-2-封裝保護妳的小秘密)
*   [Chapter 3. 建構子：物件的誕生時刻](#chapter-3-建構子物件的誕生時刻)
*   [Chapter 4. 集合 List：收納達人的必備技能](#chapter-4-集合-list收納達人的必備技能)
*   [Chapter 5. 靜態 Static：貼在客廳的公共便利貼](#chapter-5-靜態-static貼在客廳的公共便利貼)
*   [Chapter 6. 例外處理：未雨綢繆的安全網](#chapter-6-例外處理未雨綢繆的安全網)
*   [Chapter 7. 繼承：生物學與分類的智慧](#chapter-7-繼承生物學與分類的智慧)
*   [Chapter 8. 多型：同一顆按鈕，不同的功能](#chapter-8-多型同一顆按鈕不同的功能)
*   [Chapter 9. 介面 Interface：大家遵守的契約](#chapter-9-介面-interface大家遵守的契約)
*   [Chapter 10. 抽象類別 Abstract：不能具象化的概念](#chapter-10-抽象類別-abstract不能具象化的概念)
*   [Chapter 11. 組合 Composition：擁有比繼承更好](#chapter-11-組合-composition擁有比繼承更好)
*   [Chapter 12. 期末專案：Daily Buddy 完整版](#chapter-12-期末專案daily-buddy-完整版)

---

## Chapter 1. 類別與物件：程式裡的「模具」與「成品」

### 1.1 學習目標
*   理解什麼是 `class`（類別）和 `object`（物件）。
*   學會定義一個類別，並產生它的實體。
*   **專案里程碑**：建立「訊息 (Message)」的基本結構。

### 1.2 核心概念：模具 vs. 餅乾

這是物件導向最最最基礎的概念，請想像妳在做造型餅乾：

1.  **類別 (Class)** 是 **「餅乾模具」**。
    *   它規定了餅乾的形狀（星星型、愛心型）。
    *   模具本身不能吃，它只是一張「設計圖」或「規格書」。
    *   在程式碼中，我們用 `class` 關鍵字來定義它。

2.  **物件 (Object)** 是 **「烤出來的餅乾」**。
    *   用同一個模具，可以烤出無數個餅乾。
    *   每一個餅乾都是獨立的實體（Instance），這片被咬了一口，不會影響到那一片。
    *   在程式碼中，我們用 `new` 關鍵字來「烤」出一個物件。

### 1.3 示範：定義一個「訊息」

在我們的專案中，小逸和小悅會互相傳送關心訊息。我們來定義什麼是一個「訊息」。

```csharp
// --- 定義類別 (模具) ---
// 這裡我們定義了一個叫做 DailyMessage 的類別
public class DailyMessage
{
    // 這些是「欄位 (Field)」，代表這個物件擁有的「狀態」或「資料」
    public string Sender;   // 誰寄的？
    public string Content;  // 內容是什麼？
    
    // 這是「方法 (Method)」，代表這個物件可以做的「行為」
    public void Show()
    {
        Console.WriteLine($"[新訊息] {Sender} 說：{Content}");
    }
}

// --- 主程式 (使用模具) ---
class Program
{
    static void Main(string[] args)
    {
        // 1. 建立物件 (烤第一片餅乾)
        // new DailyMessage() 就是「根據模具產生一個新物件」
        DailyMessage msg1 = new DailyMessage();
        
        // 2. 設定狀態
        msg1.Sender = "小逸";
        msg1.Content = "早安！記得吃早餐喔～";

        // 3. 呼叫行為
        msg1.Show(); // 螢幕輸出：[新訊息] 小逸 說：早安！記得吃早餐喔～

        // ---
        
        // 4. 建立另一個物件 (烤第二片餅乾)
        // msg1 和 msg2 是完全獨立的！
        DailyMessage msg2 = new DailyMessage();
        msg2.Sender = "小悅";
        msg2.Content = "我已經在吃菠蘿油了 XD";

        msg2.Show(); // 螢幕輸出：[新訊息] 小悅 說：我已經在吃菠蘿油了 XD
    }
}
```

### 1.4 逐行解釋
*   `public class DailyMessage`：宣告一個公開的類別，名字叫 `DailyMessage`。習慣上類別名稱首字大寫。
*   `public string Sender;`：這是「欄位」，用來存資料。`public` 代表外面的人可以直接修改它（這之後會改進，先暫時這樣用）。
*   `DailyMessage msg1 = new DailyMessage();`：
    *   `DailyMessage` (左邊)：告訴電腦 `msg1` 這個變數的型別是 `DailyMessage`。
    *   `msg1`：這是變數名稱，就像這塊餅乾的「標籤」。
    *   `new DailyMessage()` (右邊)：電腦會在記憶體中切出一塊空間，真正建立一個物件。

### 1.5 常見錯誤
```csharp
// ❌ 錯誤示範
DailyMessage msg;
msg.Sender = "小逸";
// 💥 執行時會報錯：NullReferenceException
// 為什麼？因為妳只有寫標籤 (變數)，但沒有用 new 把它「烤」出來！
// 就像妳拿著一張寫著「餅乾」的便利貼，但桌上根本沒有餅乾。
```

### 1.6 小練習
1.  建立一個 `Pet`（寵物）類別，有 `Name`（名字）和 `Type`（種類，如貓或狗）兩個欄位。
2.  在 `Pet` 類別中加入一個 `SayHi` 方法，印出「我是 [種類] [名字]，你好！」。
3.  在 `Main` 方法中，建立兩隻不同的寵物並呼叫 `SayHi`。

<details>
<summary>點我看解答思路</summary>

```csharp
public class Pet 
{
    public string Name;
    public string Type;

    public void SayHi()
    {
        Console.WriteLine($"我是 {Type} {Name}，你好！");
    }
}

// 用法：
// Pet myCat = new Pet();
// myCat.Name = "LEGO";
// myCat.Type = "貓";
// myCat.SayHi();
```
</details>

---

## Chapter 2. 封裝：保護妳的小秘密

### 2.1 學習目標
*   理解為什麼不能什麼都 `public`。
*   學會使用 `private` 和 `Property`（屬性）來保護資料。
*   **專案里程碑**：升級「待辦事項 (Todo)」的安全性。

### 2.2 核心概念：日記本上的鎖

在上一章，我們用 `public string Sender;`，這就像是把日記本攤開在桌上，任何人都能拿筆去塗改內容，這樣很不安全。

**封裝 (Encapsulation)** 就是把物件的內部資料「藏起來」，只提供特定的「窗口」讓外面存取。
*   **private (私有)**：只有類別自己內部看得到（上鎖）。
*   **public (公開)**：大家都看得到。
*   **Property (屬性)**：控制讀寫的「窗口」。

### 2.3 示範：安全的待辦事項

我們來做一個 `TodoItem`（待辦事項）類別。

```csharp
public class TodoItem
{
    // 1. 私有欄位 (Private Field)：加上底線 _ 是 C# 的命名習慣
    // 這裡存著真正的資料，但外面的人摸不到
    private string _title;
    private bool _isCompleted;

    // 2. 公開屬性 (Public Property)
    // 這是對外的窗口
    public string Title
    {
        get 
        { 
            return _title; // 當有人要讀取時，把私有資料給他
        }
        set 
        { 
            // set 有一個神奇的變數叫 value，代表外部傳進來的值
            // 我們可以在這裡做檢查！(輸入驗證)
            if (string.IsNullOrWhiteSpace(value)) 
            {
                Console.WriteLine("❌ 錯誤：待辦事項標題不能是空的！");
            }
            else
            {
                _title = value; // 檢查通過，才真的存進去
            }
        }
    }

    // 簡寫版屬性 (Auto-implemented Property)
    // 如果不需要做檢查，C# 允許這樣寫，它會自動幫妳產生背後的 private 欄位
    public bool IsCompleted { get; set; }

    public void ShowInfo()
    {
        // 這裡可以用三元運算子： (條件) ? 符合 : 不符合
        string status = IsCompleted ? "[已完成]" : "[未完成]";
        Console.WriteLine($"{status} {Title}");
    }
}

class Program
{
    static void Main(string[] args)
    {
        TodoItem task = new TodoItem();
        
        // 透過屬性設定 (會觸發 set)
        task.Title = ""; // 試著設空字串 -> 會印出錯誤訊息，不會存進去
        
        task.Title = "買牛奶"; // 這是合法的 -> 存入 _title
        task.IsCompleted = false;

        task.ShowInfo(); // 輸出：[未完成] 買牛奶
        
        // task._title = "惡作劇"; // ❌ 報錯！無法存取 private 欄位
    }
}
```

### 2.4 逐行解釋
*   `private string _title;`：這個變數被牆壁擋住了，`Main` 程式裡看不到它。
*   `public string Title { get; set; }`：這是大門。
    *   `get`：有人想看標題時執行。
    *   `set`：有人想改標題時執行。在這裡我們加了 `if` 判斷，防止資料被設成不合理的空值。這就是封裝的好處！
*   `Auto-implemented Property`：`public bool IsCompleted { get; set; }` 是 C# 的語法糖（簡寫），適合單純讀寫的資料。

### 2.5 常見錯誤
```csharp
// ❌ 錯誤觀念
public string Title;
// 許多新手覺得用 public 欄位很方便。
// 但如果未來妳希望「設定標題時自動去除前後空白」，
// 用 public 欄位的話，妳得去改幾百個用到它的地方。
// 用 Property 的話，只要改 set 裡面那一塊就好。
```

### 2.6 小練習
1.  修改之前的 `DailyMessage` 類別。
2.  將 `Sender` 和 `Content` 改為 Property。
3.  在 `Content` 的 `set` 中加入檢查：如果訊息內容超過 10 個字，就印出「訊息太長了，請長話短說！」，並且不要存入。

<details>
<summary>點我看解答思路</summary>

```csharp
public class DailyMessage
{
    public string Sender { get; set; } // 簡單屬性

    private string _content;
    public string Content 
    {
        get { return _content; }
        set 
        {
            if (value.Length > 10)
            {
                Console.WriteLine("訊息太長了，請長話短說！");
            }
            else
            {
                _content = value;
            }
        }
    }
}
```
</details>

---

## Chapter 3. 建構子：物件的誕生時刻

### 3.1 學習目標
*   理解什麼是建構子（Constructor）。
*   學會用 `this` 關鍵字。
*   **專案里程碑**：讓 `TodoItem` 建立時就必須有標題。

### 3.2 核心概念：速食店的套餐點餐

之前的寫法：
```csharp
TodoItem t = new TodoItem();
t.Title = "洗衣服"; // 萬一我忘了寫這一行？
```
這就像去速食店點餐，店員給了妳托盤（物件建立了），但上面是空的，妳還得一樣一樣去櫃檯要漢堡。

**建構子 (Constructor)** 就像是「點套餐」。
當妳說 `new TodoItem("洗衣服")` 時，一定要同時把標題交出來，物件建立好時，資料就已經準備好了（漢堡已經在托盤上了）。

### 3.3 示範：強制初始化的待辦事項

```csharp
public class TodoItem
{
    public string Title { get; set; }
    public bool IsCompleted { get; set; }

    // --- 這就是建構子 ---
    // 1. 沒有回傳型別 (連 void 都不寫)
    // 2. 名字必須跟類別一模一樣
    public TodoItem(string title)
    {
        // "this" 代表「這個物件自己」
        // 左邊的 Title 是屬性，右邊的 title 是參數
        this.Title = title;
        
        // 設定預設值
        this.IsCompleted = false; // 一開始當然是未完成
    }
    
    // 我們也可以保留一個不帶參數的建構子，看需求
    // public TodoItem() { }
}

class Program
{
    static void Main(string[] args)
    {
        // ❌ 這樣寫會報錯！因為我們規定必須提供 title 才能建立物件
        // TodoItem t1 = new TodoItem(); 
        
        // ✅ 正確寫法：一出生就有名字
        TodoItem t2 = new TodoItem("去頂好 wellcome買菜");
        
        Console.WriteLine(t2.Title); // 輸出：去頂好 wellcome買菜
    }
}
```

### 3.4 逐行解釋
*   `public TodoItem(string title)`：這是這個類別的「入口檢查站」。要產生實體，必須通過這裡。
*   `this.Title = title;`：
    *   新手常搞混「哪個 title 是哪個」。
    *   **口訣**：`this.` 開頭的是「成員」（屬於這個物件長久的屬性）。
    *   沒加 `this` 的通常是「參數」（暫時傳進來的）。

### 3.5 常見錯誤
```csharp
// ❌ 錯誤：試圖給建構子加回傳型別
public void TodoItem(string title) { ... }
// 電腦會以為這只是一個剛好叫 TodoItem 的普通方法，而不是建構子。
```

### 3.6 小練習
1.  為 `DailyMessage` 類別加入建構子。
2.  要求建立訊息時，必須同時提供 `sender` (寄件者) 和 `content` (內容)。
3.  在 `Main` 中測試它。

---

## Chapter 4. 集合 List：收納達人的必備技能

### 4.1 學習目標
*   理解為什麼陣列（Array）不夠用。
*   學會使用 `List<T>` 來儲存一堆物件。
*   **專案里程碑**：小逸和小悅的 **「互動紀錄本」**（可以存很多訊息和待辦）。

### 4.2 核心概念：伸縮自如的收納箱

妳可能學過陣列 `string[]`，但陣列有一個大缺點：**長度固定**。就像買了一個只有 5 格的蛋盒，想裝第 6 顆蛋就裝不下。

但在專案中，我們不知道今天會有幾則訊息、幾個待辦。
這時我們要用 **`List<T>` (串列)**。
*   它就像「哆啦A夢的口袋」，可以一直塞、一直塞，它會自動變大。
*   `<T>` 叫做 **泛型 (Generic)**，意思是「妳要規定這個口袋專門裝什麼」。
    *   `List<string>`：專門裝字串的口袋。
    *   `List<TodoItem>`：專門裝待辦事項的口袋。

### 4.3 示範：Daily Buddy 的核心功能

我們來寫一段稍微長一點的程式，模擬小逸和小悅的一天。

```csharp
// 記得引用這個命名空間，才能用 List
using System.Collections.Generic; 

public class TodoItem
{
    public string Title { get; set; }
    public bool IsCompleted { get; set; }
    public TodoItem(string title) { Title = title; IsCompleted = false; }
}

class Program
{
    static void Main(string[] args)
    {
        // --- 1. 建立一個清單來存待辦事項 ---
        // 語法：List<型別> 變數名 = new List<型別>();
        List<TodoItem> todoList = new List<TodoItem>();

        // --- 2. 新增項目 (Add) ---
        // 想像小逸在列清單
        todoList.Add(new TodoItem("早上 9 點開會"));
        todoList.Add(new TodoItem("記得吃藥"));
        todoList.Add(new TodoItem("去領包裹"));

        // --- 3. 讀取與修改 ---
        // 假設小逸吃完藥了，把第 2 個項目 (索引 1) 標示為完成
        todoList[1].IsCompleted = true;

        // --- 4. 移除項目 (Remove) ---
        // 假設包裹領完了，想把這條刪掉
        // List 的 Remove 需要「物件本身」或「索引」。這裡我們用索引移除第 3 個 (索引 2)
        todoList.RemoveAt(2);

        // --- 5. 顯示所有項目 (Foreach 迴圈) ---
        Console.WriteLine("=== 小逸的今日待辦 ===");
        
        // 這裡的 foreach 意思是：
        // 對 todoList 裡面的「每一個」item (型別是 TodoItem)...
        foreach (TodoItem item in todoList)
        {
            string state = item.IsCompleted ? "[V]" : "[ ]";
            Console.WriteLine($"{state} {item.Title}");
        }
        
        // --- 6. 看看總共有幾項 (Count) ---
        Console.WriteLine($"\n目前還剩下 {todoList.Count} 個項目要追蹤。");
    }
}
```

### 4.4 逐行解釋
*   `List<TodoItem>`：宣告這是一個「專門放 TodoItem」的清單。如果妳試圖把 `string` 放進去，編譯器會報錯（這是好事，保護妳別裝錯東西）。
*   `.Add(...)`：把東西加到尾端。
*   `todoList[1]`：跟陣列一樣，用索引拿資料，從 0 開始數。
*   `foreach (var item in list)`：這是遍歷集合最常用的迴圈，比 `for` 簡單，它會自動從第一跑到最後一個。

### 4.5 常見錯誤
```csharp
List<TodoItem> list;
list.Add(new TodoItem("...")); 
// 💥 NullReferenceException！
// 雖然宣告了 List，但沒有 new 出來 (沒有買口袋)，就想塞東西。
// 記得一定要 = new List<...>();
```

### 4.6 章末小測驗
1.  `class` 和 `object` 哪個是設計圖？哪個是實體？
2.  如果不希望外部直接修改欄位，應該用什麼關鍵字？(`public` / `private`)
3.  要建立一個「存放整數的清單」，應該怎麼寫？ (`List<int>`)

---

## Chapter 5. 靜態 Static：貼在客廳的公共便利貼

### 5.1 學習目標
*   分辨「靜態（Static）」與「非靜態（Instance）」的差別。
*   理解什麼時候該用 Static。
*   **專案里程碑**：計算「總共累積了幾條紀錄」的統計功能。

### 5.2 核心概念：手錶 vs. 客廳時鐘

*   **非靜態 (Instance)**：就像 **「手錶」**。
    *   小逸有小逸的手錶，小悅有小悅的手錶。
    *   小逸把手錶調快 5 分鐘，小悅的手錶不會變。
    *   `DailyMessage` 的 `Sender` 就是非靜態的，每則訊息的寄件者都不同。

*   **靜態 (Static)**：就像 **「客廳的時鐘」**。
    *   只有一個，大家看的是同一個時間。
    *   如果有人把它撥慢了，所有人看到的時間都會變慢。
    *   在程式中，加上 `static` 關鍵字，它就屬於「類別本身」，而不是屬於「某個物件」。

### 5.3 示範：全域計數器

我們來統計一下，今天小逸和小悅總共創造了多少個待辦事項。

```csharp
public class TodoItem
{
    public string Title { get; set; }
    
    // --- 靜態欄位 ---
    // 加上 static，這個變數就只有一份，所有 TodoItem 共用它
    public static int TotalCount = 0;

    public TodoItem(string title)
    {
        Title = title;
        // 每次建立新待辦，就把計數器 + 1
        TotalCount++; 
    }
}

class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine($"一開始的數量：{TodoItem.TotalCount}"); // 0

        TodoItem t1 = new TodoItem("買早餐");
        TodoItem t2 = new TodoItem("慢跑");
        
        // 注意：存取 static 成員時，要用「類別名稱」點它，而不是變數名稱
        Console.WriteLine($"目前的數量：{TodoItem.TotalCount}"); // 2
        
        // Console.WriteLine(t1.TotalCount); // ❌ 錯誤！t1 是物件，不能存取靜態成員
    }
}
```

### 5.4 逐行解釋
*   `public static int TotalCount = 0;`：這張便利貼貼在牆上，而不是放在每個人的口袋裡。
*   `TodoItem.TotalCount`：因為它是靜態的，所以我們要呼叫「模具的名字」來找到它。

### 5.5 小練習
1.  建立一個 `DailyStats`（每日統計）類別。
2.  加入一個靜態方法 `ShowWelcome()`，印出「歡迎使用 Daily Buddy！」。
3.  在 `Main` 程式的一開始，還沒建立任何物件前，先呼叫這個方法。

---

## Chapter 6. 例外處理：未雨綢繆的安全網

### 6.1 學習目標
*   理解什麼是例外（Exception）。
*   學會用 `try-catch` 接住錯誤，不讓程式崩潰。
*   **專案里程碑**：加入「心情記錄 (MoodEntry)」並防止輸入錯誤。

### 6.2 核心概念：走鋼索的安全網

程式執行時難免會有意外，比如：
*   要妳輸入數字，妳輸入了 "ABC"。
*   要把檔案存檔，結果硬碟滿了。

如果不處理，程式會直接「閃退」（Crash），這體驗很差。
**例外處理**就像是在底下架設一張安全網，就算掉下來了，也能優雅地爬起來，告訴使用者發生了什麼事。

### 6.3 示範：心情指數檢測

我們來做一個功能：輸入心情指數（1~5 分）。

```csharp
class Program
{
    static void Main(string[] args)
    {
        Console.Write("請輸入今天的心情指數 (1-5)：");
        string input = Console.ReadLine(); // 讀取使用者輸入

        try 
        {
            // --- 危險區：這裡可能會出錯 ---
            int score = int.Parse(input); // 試著把字串轉成整數
            
            // 檢查範圍
            if (score < 1 || score > 5)
            {
                // 我們也可以自己「丟出」一個錯誤
                throw new Exception("指數必須在 1 到 5 之間！");
            }

            Console.WriteLine($"記錄成功：心情指數 {score}");
        }
        catch (FormatException) // 專門捕捉「格式錯誤」(例如輸入 "haha")
        {
            Console.WriteLine("❌ 錯誤：請輸入「數字」，不要輸入文字！");
        }
        catch (Exception ex) // 捕捉所有其他錯誤 (包含我們自己丟出的)
        {
            Console.WriteLine($"❌ 發生錯誤：{ex.Message}");
        }
        finally
        {
            // --- 善後區：不管有沒有錯都會執行 ---
            Console.WriteLine("--- 記錄結束 ---");
        }
    }
}
```

### 6.4 逐行解釋
*   `try { ... }`：把可能出事的程式碼包起來。
*   `catch (...) { ... }`：如果發生了括號內的錯誤，就跳進來這裡執行。
*   `throw new Exception(...)`：主動告訴系統「出事了！」。

### 6.5 常見錯誤
*   **空泛的 catch**：`catch { }` 裡面什麼都不寫。這樣程式出錯了妳也完全不知道為什麼（這種叫「吃掉例外」），除錯時會很痛苦。

---

## Chapter 7. 繼承：生物學與分類的智慧

### 7.1 學習目標
*   理解繼承（Inheritance）的意義：`Is-A`（是一個）。
*   學會用 `base` 和 `protected`。
*   **專案里程碑**：重構專案，將 Message、Todo、Mood 統整起來。

### 7.2 核心概念：分類帽

看看我們的專案，目前有 `DailyMessage`、`TodoItem`，接下來還有 `MoodEntry`。
它們都有一些**共同點**：
*   都有 `CreateTime`（建立時間）。
*   都有 `Author`（是誰寫的）。

如果每個類別都重寫一次這兩個欄位，就很囉唆。
我們可以定義一個 **「父親」**（父類別/基底類別），把共用的東西放進去，然後讓大家去 **「繼承」** 它。

### 7.3 示範：DailyEntry 基底類別

```csharp
// --- 1. 定義父類別 (共用的部分) ---
public class DailyEntry
{
    public DateTime CreateTime { get; set; }
    public string Author { get; set; }

    public DailyEntry(string author)
    {
        Author = author;
        CreateTime = DateTime.Now; // 自動設為現在時間
    }

    public void ShowMetadata()
    {
        Console.WriteLine($"[{CreateTime:HH:mm}] 由 {Author} 建立");
    }
}

// --- 2. 定義子類別 (繼承 DailyEntry) ---
// 語法：class 子類別 : 父類別
public class TodoItem : DailyEntry
{
    public string Title { get; set; }

    // 建構子也要傳承！
    // base(author) 意思是：呼叫爸爸的建構子，把 author 傳給它處理
    public TodoItem(string author, string title) : base(author)
    {
        Title = title;
    }
}

public class MoodEntry : DailyEntry
{
    public int Score { get; set; }

    public MoodEntry(string author, int score) : base(author)
    {
        Score = score;
    }
}

// --- 主程式 ---
class Program
{
    static void Main(string[] args)
    {
        TodoItem t = new TodoItem("小逸", "洗碗");
        t.ShowMetadata(); // 呼叫爸爸的方法！ -> [10:30] 由 小逸 建立
        Console.WriteLine($"事項：{t.Title}");
    }
}
```

### 7.4 逐行解釋
*   `class TodoItem : DailyEntry`：這行代表 `TodoItem` **是一個 (Is-A)** `DailyEntry`。它自動擁有了 `Author` 和 `CreateTime`。
*   `base(author)`：因為爸爸規定建立時要有 `author`，所以孩子在出生時，必須先把這個資料往上傳給爸爸。

---

## Chapter 8. 多型：同一顆按鈕，不同的功能

### 8.1 學習目標
*   理解多型（Polymorphism）。
*   學會 `virtual`（虛擬）與 `override`（覆寫）。
*   **專案里程碑**：用一個 List 同時管理訊息、待辦和心情！

### 8.2 核心概念：萬能遙控器

想像妳拿著一支遙控器，上面有一個「電源鍵」。
*   對著電視按：電視開了。
*   對著冷氣按：冷氣開了。

同一個動作（按下電源），對不同的對象，產生不同的反應。這就是 **多型**。

### 8.3 示範：統一的「顯示」功能

我們希望每個 Entry 都有一個 `Display()` 方法，但每種 Entry 顯示的方式不一樣。

```csharp
public class DailyEntry
{
    // virtual: 允許子類別「修改」這個方法
    public virtual void Display()
    {
        Console.WriteLine("這是一條普通的紀錄。");
    }
}

public class TodoItem : DailyEntry
{
    /* ... 建構子省略 ... */
    public string Title { get; set; }

    // override: 我要修改爸爸的方法！
    public override void Display()
    {
        Console.WriteLine($"[待辦] {Title}");
    }
}

public class MoodEntry : DailyEntry
{
    /* ... 建構子省略 ... */
    public int Score { get; set; }

    public override void Display()
    {
        string stars = new string('★', Score); // 產生星星字串
        Console.WriteLine($"[心情] {stars} ({Score}分)");
    }
}

class Program
{
    static void Main(string[] args)
    {
        // 驚人的魔法來了！
        // 我們可以用一個 List<DailyEntry> 裝各種不同的子類別
        List<DailyEntry> diary = new List<DailyEntry>();

        diary.Add(new TodoItem("小逸", "倒垃圾"));
        diary.Add(new MoodEntry("小悅", 5));
        diary.Add(new TodoItem("小逸", "繳費"));

        Console.WriteLine("=== 今日總覽 ===");
        foreach (DailyEntry entry in diary)
        {
            // 雖然變數型別是 DailyEntry，但執行時會自動找到「真正的子類別」去執行
            entry.Display(); 
        }
    }
}
```

### 8.4 執行結果
```text
=== 今日總覽 ===
[待辦] 倒垃圾
[心情] ★★★★★ (5分)
[待辦] 繳費
```
這就是多型的威力！我們不需要寫一堆 `if (entry is TodoItem) ... else if ...`，只要呼叫 `Display()`，物件自己知道該怎麼做。

### 8.5 章末小測驗
1.  如果要共用一個變數（例如計數器），應該用什麼關鍵字？ (`static`)
2.  如果不希望程式因為輸入錯誤而閃退，要用什麼區塊包起來？ (`try-catch`)
3.  如果要讓子類別修改父類別的方法，父類別的方法要加什麼關鍵字？ (`virtual`)

---

## Chapter 9. 介面 Interface：大家遵守的契約

### 9.1 學習目標
*   理解什麼是介面（Interface）。
*   知道介面與繼承的差別。
*   **專案里程碑**：讓不同的物件都能被「分享」到社群軟體。

### 9.2 核心概念：USB 插孔

妳的電腦上有 USB 插孔，你可以插隨身碟、插滑鼠、插鍵盤。
電腦不在乎你插的是什麼牌子，只要那個裝置 **「遵守 USB 的規格」** 就好。

**介面 (Interface)** 就是這個「規格」。
它只規定 **「必須有哪些方法」**，但不規定怎麼做。

### 9.3 示範：可分享的功能

假設我們希望某些項目可以被「分享」出去（產生一段文字）。

```csharp
// 習慣上介面名稱會用 I 開頭
public interface IShareable
{
    // 介面裡面只寫「方法簽章」，不寫實作內容
    string GetShareText();
}

// 讓 MoodEntry 遵守這個契約
public class MoodEntry : DailyEntry, IShareable
{
    /* ... 屬性與建構子省略 ... */
    
    // 實作介面要求的方法
    public string GetShareText()
    {
        return "我今天心情 " + Score + " 分，想找人聊聊！";
    }
}

public class TodoItem : DailyEntry, IShareable
{
    /* ... */
    public string GetShareText()
    {
        return "[忙碌中] 正在處理：" + Title;
    }
}

class Program
{
    static void Main(string[] args)
    {
        // 我們可以建立一個清單，裡面只裝「遵守 IShareable 的東西」
        List<IShareable> shareList = new List<IShareable>();
        
        shareList.Add(new MoodEntry("小悅", 5));
        shareList.Add(new TodoItem("小逸", "寫報告"));

        foreach (var item in shareList)
        {
            // 這裡我不在乎它是 Mood 還是 Todo，我只知道它一定可以 GetShareText
            Console.WriteLine("分享到 IG: " + item.GetShareText());
        }
    }
}
```

### 9.4 逐行解釋
*   `interface IShareable`：這是一個合約，簽了名的類別，就必須提供 `GetShareText()` 功能。
*   `class MoodEntry : DailyEntry, IShareable`：C# 只能有一個爸爸（繼承一個類別），但可以簽很多合約（實作多個介面）。

---

## Chapter 10. 抽象類別 Abstract：不能具象化的概念

### 10.1 學習目標
*   理解 `abstract` 關鍵字。
*   區分 Abstract Class 與 Interface。

### 10.2 核心概念：動物 vs. 貓

妳可以養一隻「貓」，可以養一隻「狗」，但妳不能去寵物店說要買一隻「動物」。
「動物」是一個**抽象**的概念，它不能單獨存在。

在我們的專案中，`DailyEntry` 其實也是一個抽象概念。妳不會寫一張「沒有內容的紀錄」，妳一定是寫「待辦」或「心情」。

### 10.3 示範：禁止建立 DailyEntry

```csharp
// 加上 abstract，這個類別就不能被 new 出來了
public abstract class DailyEntry
{
    public DateTime CreateTime { get; set; }
    /* ... */
    
    // 抽象方法：連方法內容都不寫了，強制孩子一定要重寫
    public abstract void Display();
}

class Program
{
    static void Main(string[] args)
    {
        // DailyEntry d = new DailyEntry("某人"); // ❌ 報錯！無法建立抽象類別的實體
        
        DailyEntry d = new TodoItem("某人", "工作"); // ✅ 但可以用來當變數型別
    }
}
```

---

## Chapter 11. 組合 Composition：擁有比繼承更好

### 11.1 學習目標
*   理解 **Has-A**（擁有）的關係。
*   學會用類別包含另一個類別。
*   **專案里程碑**：建立 `DailySummary`（每日摘要），它「擁有」一份紀錄清單。

### 11.2 核心概念：電腦與 CPU

一台電腦 **擁有 (Has-A)** 一個 CPU，而不是 電腦 **是 (Is-A)** 一個 CPU。
在設計程式時，儘量多用「組合」，少用「繼承」。因為繼承一旦層級太深，會變得很難維護。

### 11.3 示範：每日摘要報告

```csharp
public class DailySummary
{
    public DateTime Date { get; set; }
    
    // 這裡用了組合：DailySummary 裡面包含了一個 List
    private List<DailyEntry> _entries = new List<DailyEntry>();

    public void AddEntry(DailyEntry entry)
    {
        _entries.Add(entry);
    }

    public void PrintReport()
    {
        Console.WriteLine($"=== {Date:yyyy/MM/dd} 日報表 ===");
        Console.WriteLine($"總共有 {_entries.Count} 條紀錄");
        foreach(var entry in _entries)
        {
            entry.Display();
        }
    }
}
```

---

## Chapter 12. 期末專案：Daily Buddy 完整版

最後，我們把所有學到的東西，組裝成一個可以互動的 Console App。

### 12.1 完整程式碼結構

1.  **DailyEntry** (抽象父類別)
2.  **TodoItem** (繼承 DailyEntry, 實作 IShareable)
3.  **MoodEntry** (繼承 DailyEntry, 實作 IShareable)
4.  **DailySummary** (管理類別，使用組合)
5.  **Program** (使用者介面與迴圈)

### 12.2 程式碼實作

```csharp
using System;
using System.Collections.Generic;

// --- 介面 ---
public interface IShareable
{
    string GetShareText();
}

// --- 抽象父類別 ---
public abstract class DailyEntry
{
    public DateTime CreateTime { get; private set; }
    public string Author { get; set; }

    public DailyEntry(string author)
    {
        Author = author;
        CreateTime = DateTime.Now;
    }

    public abstract void Display();
}

// --- 子類別：待辦事項 ---
public class TodoItem : DailyEntry, IShareable
{
    public string Title { get; set; }
    public bool IsCompleted { get; set; }

    public TodoItem(string author, string title) : base(author)
    {
        Title = title;
        IsCompleted = false;
    }

    public override void Display()
    {
        string status = IsCompleted ? "[已完成]" : "[未完成]";
        Console.WriteLine($"{status} 待辦：{Title} (By {Author})");
    }

    public string GetShareText() => $"[忙碌中] 正在處理：{Title}";
}

// --- 子類別：心情紀錄 ---
public class MoodEntry : DailyEntry, IShareable
{
    public int Score { get; set; }
    public string Note { get; set; }

    public MoodEntry(string author, int score, string note) : base(author)
    {
        Score = score;
        Note = note;
    }

    public override void Display()
    {
        string stars = new string('★', Score);
        Console.WriteLine($"心情：{stars} - {Note} (By {Author})");
    }

    public string GetShareText() => $"[心情] 今天心情 {Score} 分：{Note}";
}

// --- 管理類別 ---
public class DailyManager
{
    private List<DailyEntry> _entries = new List<DailyEntry>();

    public void AddEntry(DailyEntry entry)
    {
        _entries.Add(entry);
    }

    public void ShowAll()
    {
        Console.WriteLine("\n=== 今日所有紀錄 ===");
        if (_entries.Count == 0) Console.WriteLine("目前沒有紀錄。");
        
        foreach (var entry in _entries)
        {
            entry.Display();
        }
        Console.WriteLine("====================\n");
    }
}

// --- 主程式 ---
class Program
{
    static void Main(string[] args)
    {
        DailyManager manager = new DailyManager();
        string currentUser = "小逸"; // 預設使用者

        Console.WriteLine("歡迎使用 Daily Buddy 日常互助小助理！");

        while (true)
        {
            Console.WriteLine($"嗨，{currentUser}！請選擇功能：");
            Console.WriteLine("1. 新增待辦事項");
            Console.WriteLine("2. 新增心情紀錄");
            Console.WriteLine("3. 查看今日摘要");
            Console.WriteLine("4. 離開");
            Console.Write("> ");

            string choice = Console.ReadLine();

            try
            {
                if (choice == "1")
                {
                    Console.Write("請輸入待辦事項：");
                    string title = Console.ReadLine();
                    manager.AddEntry(new TodoItem(currentUser, title));
                    Console.WriteLine("✅ 已新增待辦！");
                }
                else if (choice == "2")
                {
                    Console.Write("請輸入心情指數 (1-5)：");
                    int score = int.Parse(Console.ReadLine());
                    if (score < 1 || score > 5) throw new Exception("分數要在 1-5 之間");

                    Console.Write("想說的一句話：");
                    string note = Console.ReadLine();
                    manager.AddEntry(new MoodEntry(currentUser, score, note));
                    Console.WriteLine("✅ 已記錄心情！");
                }
                else if (choice == "3")
                {
                    manager.ShowAll();
                }
                else if (choice == "4")
                {
                    Console.WriteLine("掰掰！明天見～");
                    break;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"❌ 發生錯誤：{ex.Message}");
            }
            
            Console.WriteLine(); // 空一行比較好看
        }
    }
}
```

---

## 附錄：詞彙表與速查表

| 關鍵字 | 中文 | 白話解釋 |
| :--- | :--- | :--- |
| **Class** | 類別 | 餅乾的模具，定義物件長怎樣。 |
| **Object** | 物件 | 烤出來的餅乾，實際存在的東西。 |
| **New** | 建立 | 烤餅乾的動作。 |
| **Property** | 屬性 | 類別的特徵（如：名字、顏色），通常有 get/set。 |
| **Method** | 方法 | 物件可以做的動作（如：打招呼、計算）。 |
| **Constructor** | 建構子 | 物件出生時執行的第一個方法（點套餐）。 |
| **Private** | 私有 | 只有自己看得到（日記本上鎖）。 |
| **Public** | 公開 | 大家都看得到。 |
| **Static** | 靜態 | 屬於類別的，大家共用一份（牆上的時鐘）。 |
| **Inheritance** | 繼承 | 爸爸與兒子的關係，繼承可以拿到爸爸的所有東西。 |
| **Interface** | 介面 | 插座規格，規定「必須要有什麼功能」，不管你怎麼做。 |

---

> **恭喜妳！**
> 妳已經完成了 C# 物件導向的完整旅程。
> 從一開始連 `class` 是什麼都不知道，到現在能寫出一個有繼承、有介面、能互動的 `Daily Buddy`，妳真的很棒！
> 程式這條路很長，但只要保持好奇心，把複雜的問題拆解成一個個小物件，就沒有什麼能難倒妳的。
> 加油！

```