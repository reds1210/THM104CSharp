型別
===
在C#中，"型別"（Type）指的是變數或表達式的類型，它定義了數據的性質以及可以在其上執行的操作。C#是一種強型別語言，這意味著每個變數在編譯時都必須具有一個確定的型別，而且不能隨意改變。型別提供編譯器和運行時系統用於確保程式碼正確性和安全性的信息。


架構圖
---
![](/img/value-reference-types-common-type-system.png)

>基本型別和參考型別是兩種不同的型別分類，它們在記憶體的儲存和處理方式有所不同。

1. 基本型別（Value Types）：<br>
`基本型別是一種直接包含其數據值的型別，它們存儲在堆棧（stack）上。基本型別的變數直接包含實際的數據值，當一個基本型別的變數被賦值給另一個變數時，實際的數據被複製。`

2. 參考型別（Reference Types）：<br>
`參考型別存儲在堆(Heap)上，而變數則包含一個指向實際數據的引用（記憶體地址）。當一個參考型別的變數賦值給另一個變數時，它們實際上都指向相同的數據。修改其中一個變數將影響到另一個。`

* 基本型別列表:  
  1. int：整數類型，例如 int x = 10;
  2. float、double、decimal：浮點數類型，例如 float y = 3.14f;
  3. char：字符類型，例如 char c = 'A';
  4. bool：布林類型，例如 bool flag = true;
  5. struct：結構，是一種較輕量級的值型別。
* 參考型別列表:
  1. string：字符串類型，例如 string name = "John";(**特殊的參考型別，原型是char陣列組成。使用上視為基本型別**)
  2. object：所有類型的基類，可以包含任何類型的值。
  3. class：類型，是一種引用型別，可以包含數據和方法。
  4. interface：接口，定義了一組相關的方法和屬性，實現該接口的類必須提供相應的實現。
   

結構(Struct)
===
`結構是使用 struct 關鍵字來定義的，它可以包含數據成員和方法。與類別(Class)不同，結構是基本型別（Value Types），通常用於較小、較輕量的數據。`

### 基本格式
```C#
public struct Coords
{
    public Coords(double x, double y)
    {
        X = x;
        Y = y;
    }
    public double X { get;set; }
    public double Y { get;set; }
}
```
### 使用方式
```C#
  var p1 = new Coords(0, 0);
  Console.WriteLine(p1);  // output: (0, 0)

  p1.X = 5;

  var p2 = p1;
  Console.WriteLine(p2);  // output: (5, 0)
```

列舉(Enum)
===
`enum（列舉）是C#中一種用來定義命名常數的型別。它允許你定義一個具有命名值的型別，這些值在整個應用程式中是固定的。 
通常確定不會改變值可以使用列舉`

使用情境
* 需要一組 固定且意義明確 的常數值時，如顏色、狀態碼、方向（北、南、東、西）等。
* 讓程式碼更易讀，避免直接使用硬編碼整數或字串，增加可維護性。

基本格式
---
```C#
public enum Color
{
    Red= 0,
    Green = 5,
    Blue = 10
}

//你也可以不指定數值
//數值會從上到下從0開始遞增
public enum Color
{
    Red,
    Green,
    Blue
}
```

>列舉的值從0開始，也可以指定不同的初始值。  
>可將列舉視為整數的一種命名方式，這使code更容易閱讀和理解。  
>可以透過ToString方法將其轉換為字串，也可以使用Enum.Parse方法將字串轉換為列舉值。

```C#
int num = (int)Color.Blue;
Color myColor = (Color)Enum.Parse(typeof(Color), "Blue");
Console.WriteLine($"Parsed color: {myColor.ToString()}");
```



堆棧（Stack）/堆（Heap）

# 1. 為何要區分「堆棧（Stack）」與「堆（Heap）」？
在一般的電腦程式中，記憶體管理是一個關鍵話題。C/C++ 等語言中，我們常見到「函式呼叫堆棧（Call Stack）」和「動態配置（malloc/new）於堆（Heap）」的概念；在 C# 或其他 .NET 語言中，雖然我們比較少直接「手動」管理記憶體，但依然存在類似的記憶體區域劃分。

1. **執行效率**：堆棧的配置與釋放相對簡單且快速；堆的配置與 GC（Garbage Collection）管理會相對複雜。  
2. **生命週期**：堆棧中的變數通常在方法執行完畢就被釋放；堆上的物件則由 GC 在「不再被參考時」進行自動回收。  
3. **值型別與參考型別**：C# 中一般將「值型別」配置在堆棧上，「參考型別」配置在堆上，但實務中有更多細節（例如：值型別若存在於物件內部，則隨物件被配置在堆上）。

---

# 2. 堆棧（Stack）

### 2.1 什麼是堆棧？
- 堆棧（Stack）是一種 **後進先出**（LIFO, Last-In-First-Out）的資料結構。  
- 每當程式呼叫一個方法（function），系統會在呼叫堆棧上配置一個「堆棧框架（Stack Frame）」或稱「堆棧紀錄（Stack Record）」。  
- 此堆棧框架會保存：  
  - 該方法中的**區域變數**（Local Variables）  
  - 方法呼叫的**參數**（Parameters）  
  - 方法回傳地址（Return Address）  
- 當方法結束（return）時，該堆棧框架被自動移除，區域變數也自然失效。

### 2.2 堆棧特性
1. **分配/釋放非常快速**  
   因為堆棧的空間使用只需移動堆棧指標（Stack Pointer），進入方法時「指標往上增加」，離開方法時「指標往下移回」。因此，區域變數在方法內部可被快速建立與回收，**不需**像堆（Heap）那樣依賴複雜的記憶體配置流程或垃圾回收。

2. **儲存空間有限**  
   堆棧大小通常由作業系統或執行時期在程式啟動時設定。如果堆棧空間用盡（例如遞歸函式呼叫過深或存放大量大物件），可能導致 `StackOverflowException`。

3. **典型用途**  
   - **方法呼叫**：保存參數與局部變數。  
   - **小型值型別變數**：`int`, `bool`, `double` 等通常直接存在堆棧框架中（前提是它們是區域變數或方法參數）。  

### 2.3 與值型別的關係
- **值型別**（如 `int`, `float`, `bool`, `struct` 等）在作為**區域變數**或**方法參數**時，一般就存放在堆棧上。  
- 若該值型別是**結構體**（struct），系統也會將它的所有成員在堆棧上連續配置。  
- **注意**：如果一個值型別是某個參考型別（class）物件的成員，那麼它其實隨著該物件一起被配置到「堆」上，而不是堆棧。


---

# 3. 堆（Heap）

### 3.1 什麼是堆？
- 堆（Heap）是一塊由執行時期（.NET CLR）統一管理的動態記憶體區域。  
- 在 C# 中，透過 `new` 關鍵字建立的物件（例如 `class` 實例、`string` 物件，以及陣列等等）都分配在堆上。  
- 其最大的特點是：只要你持有對該物件的參考（Reference），便可在任意位置（方法、物件欄位等）訪問該物件。

### 3.2 堆特性
1. **動態配置**  
   透過 `new` 配置物件時，.NET CLR 在「Managed Heap」上找尋合適的空間，並分配給該物件。  

2. **自動垃圾回收（Garbage Collection, GC）**  
   C# 不需要像 C++ 一樣手動釋放（`delete`），而是由 GC 機制定期檢查哪些物件「不再被任何參考」時，自動回收並釋放其佔用的記憶體空間。  
   - **標記-清除（Mark and Sweep）**、**壓縮（Compact）**等技術是 .NET GC 常用的演算法。  
   - 為了提升效能，.NET GC 還區分了世代（Generations）：Gen 0、Gen 1、Gen 2，來減少對整個堆的掃描次數。

3. **存取速度**  
   雖然存取堆上的資料在理論上不如堆棧快（因為需透過參考尋址），但在實務中，大多數場合下這個差異不是最大瓶頸，除非在極度高效能或即時系統中才需特別考量。

4. **可儲存較大型物件**  
   因為堆空間一般比堆棧要大得多，也可以彈性配置不固定大小的物件（例如陣列、字串）。  
   - **Large Object Heap (LOH)**：如果物件非常大（預設大於 85000 bytes），會進入 .NET 的 Large Object Heap，GC 針對該區域也有不同的管理策略。


---

# 4. 值型別或參考型別在堆 / 堆棧上的實際存放狀況

### 4.1 「值型別」≠ 一定在 Stack
- 若一個值型別（struct）是局部變數，通常在堆棧上。  
- 若它是「參考型別（class）」的一個欄位，則那部分儲存在該物件於堆上的那塊記憶體區。  
- 若因裝箱（Boxing）將值型別轉型為 `object`，則會在堆上建立一個新的物件來包裝該值。

### 4.2 「參考型別」≠ 一定只存指標在 Stack
- 參考型別（class）的物件主體確實在堆上，但「該物件的參考（Reference）」本身通常是個「指向該物件地址」的小型值，可能放在堆棧或其他結構中。  
- 例如：  
  ```csharp
  MyClass obj = new MyClass(); 
  ```
  - `obj`（參考）是區域變數，存放於堆棧；  
  - `new MyClass()` 創建的物件數據存放於堆；  
  - `obj` 變數保存「物件的位址」，方法結束後 `obj` 變數就不存在，但若有其他全域參考指向該物件，GC 也不會釋放。

### 4.3 GC 與記憶體釋放
- 堆上的物件何時被釋放，主要由 GC 判斷是否「再無存活參考」。  
- 一旦沒有任何參考指向該物件，該物件就成為「垃圾」，將在未來某次 GC 執行時被回收。
- 在 .NET 中，一些「具資源或環境管理需求」的類別（如 `FileStream`, `SqlConnection`, `Socket` 等）會實作 `IDisposable` 供 `using` 區塊或手動呼叫 `Dispose()` 釋放非受管資源。  
  ```csharp
  using (FileStream fs = new FileStream("test.txt", FileMode.Open))
  {
      // 使用 fs 讀寫檔案
  } // 離開 using 區塊時自動呼叫 fs.Dispose()
  ```


---

# 5. 淺談效能與設計考量

### 5.1 速度
- **堆棧**：分配 / 釋放速度快（指標位移），適用於短生命週期與小型資料。  
- **堆**：雖然分配速度不見得非常慢，但釋放需要由 GC 自動處理，且當 GC 執行時，可能造成程式暫停（暫停時間取決於 GC 的世代、物件數量等）。  

### 5.2 生命週期
- 堆棧中的變數生命週期與方法呼叫緊密綁定。方法結束後，該區域變數就失效。  
- 堆中的物件可以超出方法範圍，只要還有參考指向它就能存活，直到 GC 回收。

### 5.3 選擇結構（struct）或類別（class）
- 資料量小、短期使用、頻繁被建立/銷毀的可考慮用結構（Value Type），減少 GC 壓力。  
- 需要繼承或可能很複雜的物件，應該使用類別。  
- 若結構過大，頻繁複製也會有成本；此時類別可能更適合。

### 5.4 大型物件與 GC
- 大型陣列、影像緩衝區等會被放在 Large Object Heap（LOH）。LOH 的回收與壓縮策略不同，一次 LOH 回收可能產生相對較大的延遲。  
- 當需要大量大物件時，要考量到 GC 行為對系統延遲的影響。


---

# 6. 實務建議與結論

1. **瞭解即可，勿過度微觀優化**  
   在 C# 中，大部分時候開發者不需手動管理記憶體；把握語言設計初衷（安全、穩定、易用）即可。只有在效能或資源敏感的場景中，才需要微調設計模式。

2. **值型別與參考型別的正確使用**  
   - 小且簡單的資料結構可用值型別，減少 GC 負擔；  
   - 複雜或需要繼承的資料結構用類別（參考型別），讓程式更具彈性。

3. **理解生命週期**  
   - **堆棧**：方法執行區域，短暫且具固定順序。  
   - **堆**：隨處可用，但最終由 GC 判定何時釋放。

4. **注意裝箱/拆箱（Boxing/Unboxing）**  
   - 盡量避免在高頻率路徑執行裝箱與拆箱，因為它會將值型別放入堆上，增加 GC 負擔。

5. **記憶體大小限制與例外**  
   - 若遞歸太深或局部變數過大，可能導致 `StackOverflowException`；  
   - 若配置極大物件需考量 LOH 與 GC 的影響。

---

## 總結

- **堆棧（Stack）**：LIFO 佇列，主要用於儲存區域變數、方法參數及呼叫資訊，配置釋放都非常快速。但大小有限且生命週期與方法呼叫週期綁定。  
- **堆（Heap）**：由 .NET CLR 管理的動態記憶體空間，物件透過 `new` 配置後能被任意程式碼持有參考直至 GC 回收。可自由配置較大且複雜的物件，但需付出 GC 垃圾回收的管理成本。  



白話文解釋
---

## 堆棧（Stack） = 小桌子

- **小桌子特性**：
  1. 桌面不大（空間有限），可以很快地拿東西、放東西。
  2. 你做每件事（呼叫函式）時，就在桌面上攤開一份當下需要用的資料（這些資料包含函式的暫時變數、參數等等）。
  3. 事情做完（函式結束）後，你把那疊資料一拿，就整疊丟掉——桌面就清空了。
  4. 整理很快，因為只要照順序把最後放上來的那疊拿掉就好。  

- **對應到程式**：
  - 每次呼叫函式，C# 會在「堆棧」上開一小塊空間來放局部變數、參數等。
  - 當函式結束，這塊空間就直接釋放掉。
  - 小桌子雖然快，但是空間並不多；放東西太大或呼叫太多層函式，就會「桌子爆滿」造成 `StackOverflowException`。

- **舉個例子**：  
  - 你去文具店買 3 支筆（函式參數），店員就把 3 支筆暫時放在桌上（堆棧），幫你記住。等你付完錢、交易結束，筆也從桌上收起來給你，桌面就清空了。

---

## 堆（Heap） = 大倉庫

- **大倉庫特性**：
  1. 倉庫空間很大，可以放各種尺寸的貨物或包裹。
  2. 但要找到空位並且分配貨架位置，可能要花些力氣（配置、尋址），速度就沒桌面那麼快。
  3. 貨物放進倉庫後，只要還有「貨物的存貨卡（參考）」保留著，就表示這批貨還要繼續留在倉庫，不能丟。
  4. 如果所有人都把存貨卡丟了（沒人再關注這批貨），清潔隊（GC）就會把它整批清出去。

- **對應到程式**：
  - 透過 `new` 關鍵字建立出來的東西（物件、陣列、字串等），就「放進倉庫」。
  - 當你的程式碼有個變數拿著這份「存貨卡」（參考），就能存取倉庫裡的物件。
  - 一旦程式碼裡沒有人再需要（或記得）那份物件（存貨卡），等過一陣子大倉庫管理員（GC）掃到，會把這批貨物移除釋放，讓倉庫空下來。

- **舉個例子**：  
  - 你要拿一張大型海報，桌子上放不下，就必須放到倉庫（Heap）。只要你還持有貨物的「位置資訊」或「訂單」（變數引用），你就能在程式裡拿得到這張海報。要是你把訂單弄丟了，過一陣子保潔人員就把那張海報丟掉了。

---

## 堆棧 vs. 堆：該怎麼選？

1. **資料大小 & 生命週期**  
   - 如果是小筆資料（像 int、float、bool、短期的參數），直接放「小桌子」上最有效率。  
   - 如果是複雜或大型物件（像陣列、文字、類別物件），就必須存「大倉庫」裡。  

2. **取用速度**  
   - 「小桌子」上的東西拿取非常快，但只能先進後出，空間也比較有限。  
   - 「大倉庫」可以收超多東西，但要考慮管理費（GC）的成本。

3. **程式記憶體管理**  
   - 「小桌子」的東西結束時馬上丟掉，不必等人收。  
   - 「大倉庫」要靠垃圾回收（GC）定時檢查、清理，不用你手動管，但有時可能系統要暫停一下來做回收工作。

---
再來補充幾點，說明 **為什麼要區分「小桌子（Stack）」和「大倉庫（Heap）」** 以及各自的 **優勢**：

---

## 為什麼要區分？

1. **記憶體用法不同**  
   - 「小桌子（堆棧）」擅長應付「當下在手」的工作，放著方法內部的變數、參數。這些東西一旦用完就可以馬上收掉，乾淨俐落。  
   - 「大倉庫（堆）」專門存放體積較大、需要在程式不同地方拿取的物件，像是各種 `class`、陣列、字串等。  
   這樣分門別類，可讓執行速度與程式設計都更有效率。

2. **生命週期管理**  
   - 放在「小桌子」上的東西，隨方法執行結束就自動收掉，不必手動管理；  
   - 放在「大倉庫」裡的物件，會一直存在到沒人再需要它（沒有任何參考）時，由垃圾回收機制（GC）統一處理。  
   透過區分，可以讓我們知道哪些資料「一下子就會丟掉」，哪些「可能會留很久」。

3. **效能與空間規劃**  
   - 「小桌子」因為空間較小，可迅速存取，但無法存放太多或太大資料；  
   - 「大倉庫」空間大多了，但「拿取、整理」就複雜些，需要等人（GC）來掃描、歸檔。  
   這種區分可以避免所有資料都「堆一塊」時，導致管理混亂、效能下降。

---

## 各自的優勢

### 小桌子（Stack）
1. **分配、釋放超快速**  
   只要往上或往下移動堆棧指標，堆棧上的空間就定位或釋放了。對小型、暫時性的資料而言，再方便不過。  
2. **有序且簡單**  
   以函式呼叫為單位，先進後出，一件事結束就把那疊資料全丟掉。程式容易追蹤，也不易忘了清。  
3. **適合存放短期內的值型別**  
   像 `int x = 10;`、`bool y = false;` 等局部變數，都會放在堆棧上，存取很快。

### 大倉庫（Heap）
1. **容量大、能放各種尺寸**  
   只要還有空間，就能放下任何透過 `new` 建立的物件：如 `new MyClass()`、`new int[1000]`、`new string(...)`。  
2. **物件可以跨越方法界線**  
   即使方法結束，只要有其他地方留著該物件的參考，它就能繼續存活；比較自由。  
3. **自動垃圾回收**  
   不用你自己跟蹤到底該物件有沒有人用，GC 會在判斷「沒人要了」後自行回收。  
   你就不用像 C++ 一樣還得呼叫 `delete`，比較不易發生記憶體洩漏（Memory Leak）。

