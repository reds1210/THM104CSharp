# C# 物件導向番外篇：變形金剛大亂鬥
## —— 為什麼柯博文平常不能飛？論「介面」的重要性

> **寫給妳的話：**
> 學完了類別（Class）和繼承（Inheritance），妳可能會問：「老師，如果我要讓物件有很多功能，為什麼不全部寫在父類別（爸爸）裡就好？」
>
> 為了回答這個問題，我們今天不寫枯燥的程式，我們來去 **賽博坦星** 看看！
> 這是一個關於 **「血統（類別）」** 與 **「裝備（介面）」** 的故事。

---

## 1. 悲劇的開始：如果「飛行」是祖傳基因...

很久很久以前，在賽博坦星，我們有一個偉大的父類別（模具），叫做 `Transformer`（變形金剛）。
所有的變形金剛，不管是博派還是狂派，都是從這個模具生出來的。

```csharp
// 這是所有變形金剛的爸爸
public class Transformer
{
    public string Name { get; set; }
    
    public void Transform()
    {
        Console.WriteLine($"{Name} 變形！庫庫卡卡...（機械音");
    }
}
```

這時候，狂派的 **密卡登 (Megatron)** 和 **紅魔鬼 (Starscream)** 出現了。他們是飛機，他們會飛。
於是，懶惰的工程師想說：「既然他們是變形金剛，那就在爸爸身上加個 `Fly()` 方法吧！」

### ❌ 錯誤的設計：把飛行寫在父類別

```csharp
public class Transformer
{
    public string Name { get; set; }
    
    public void Transform() { /* ... */ }

    // 😱 災難的源頭：工程師以為每個變形金剛都會飛
    public void Fly()
    {
        Console.WriteLine($"{Name} To Infinity...and Beyond！");
    }
}
```

結果發生了什麼事？

**大黃蜂 (Bumblebee)** 出生了。他是一台雪佛蘭跑車。
他繼承了 `Transformer`，所以他... **也繼承了飛行功能**？！

```csharp
Transformer bumblebee = new Transformer { Name = "大黃蜂" };
bumblebee.Fly(); 
// 螢幕顯示：大黃蜂 飛向宇宙，浩瀚無垠！
// 眾人：😱 娘子快跟牛魔王出來看上帝....這是 Bug 吧！👻
```

這就是繼承最大的缺點：**強迫中獎**。
如果在父類別加了功能，所有的子孫（不管適不適合）通通都會被迫擁有這個功能。這在邏輯上是講不通的。

---

## 2. 救星登場：介面 (Interface) 是外掛裝備

我們發現了問題：「飛行」不應該是變形金剛的「天生基因（Class）」，它應該是一種「特殊能力（Interface）」。

*   **類別 (Inheritance)**：代表 **Is-A (你是誰)**。
    *   柯博文 **是** 變形金剛。
    *   大黃蜂 **是** 變形金剛。
*   **介面 (Interface)**：代表 **Can-Do (你會什麼)**。
    *   紅魔鬼 **會** 飛。
    *   柯博文 **不會** 飛（平常的時候）。

### ✅ 正確的設計：把飛行拆出來

我們定義一個介面，就像是一個 **「飛行裝備包」**。

```csharp
// 這是一個介面，名字通常用 I 開頭
// 它只是一張契約，代表「擁有此裝備者，必須實作飛行功能」
public interface IFlyable
{
    void Fly();
}
```

現在，我們來重新設計變形金剛：

```csharp
// 1. 基礎變形金剛 (大家都不會飛)
public class Transformer
{
    public string Name { get; set; }
}

// 2. 紅魔鬼 (狂派戰機)：他是變形金剛，而且他簽了「飛行契約」
public class Starscream : Transformer, IFlyable
{
    public void Fly()
    {
        Console.WriteLine("紅魔鬼：哈哈哈！你們這些只會在地上跑的廢鐵！(噴射氣流)");
    }
}

// 3. 大黃蜂 (博派跑車)：他只是變形金剛，沒簽合約
public class Bumblebee : Transformer
{
    public void Run()
    {
        Console.WriteLine("大黃蜂：我的時速100KM正向妳而來。");
    }
}
```

現在世界和平了：
*   紅魔鬼可以飛 (`Starscream` 有實作 `IFlyable`)。
*   大黃蜂不能飛 (他沒有 `Fly` 方法)，編譯器會阻止他亂飛。

---

## 3. 電影名場面：柯博文的逆襲

現在來到最精彩的變形金剛電影第二集。
**柯博文 (Optimus Prime)** 是一台卡車，照理說他屬於 `Transformer`，不會飛。他只能在地上看著密卡登在天上囂張。

但是！劇情需要，柯博文必須飛！
他怎麼飛？他不是突然基因突變變成飛機，他是 **「穿上了天火 (Jetfire) 的裝備」**。

這在程式碼裡，就是 **介面的靈活性**。
柯博文原本的類別沒有 `IFlyable`，但我們可以創造一個 **「合體版柯博文」**！

```csharp
// 原本的柯博文
public class OptimusPrime : Transformer
{
    public void Attack() { Console.WriteLine("柯博文：拿劍砍你！"); }
}

// --- 劇情高潮：天火老爺爺犧牲自己，把零件給了柯博文 ---

// 合體版柯博文：繼承原本的柯博文，並且「加上」了飛行介面
public class JetPoweredOptimus : OptimusPrime, IFlyable
{
    public void Fly()
    {
        Console.WriteLine("柯博文（天火裝備）：抱歉了密卡登，現在我也會飛了！(To Infinity...and Beyond！");
    }
}
```

### Let's coding

```csharp
class Program
{
    static void Main(string[] args)
    {
        // 1. 平常的柯博文
        OptimusPrime prime = new OptimusPrime();
        prime.Name = "柯博文";
        prime.Attack();
        // prime.Fly(); // ❌ 報錯！這時候他還不會飛，很合理。

        Console.WriteLine("--- 遇到強敵，天火合體！---");

        // 2. 裝備了介面的柯博文
        // 這裡我們把「飛行能力」掛載上去了
        JetPoweredOptimus superPrime = new JetPoweredOptimus();
        superPrime.Name = "柯博文(重裝版)";
        
        superPrime.Attack(); // 原本的攻擊還在
        superPrime.Fly();    // ✅ 終於飛起來了！
        
        Console.WriteLine("密卡登：...好串喎你！(被擊落");
    }
}
```

---

## 4. 總結：我該用類別還是介面？

請用這個「變形金剛法則」來判斷：

| 比較項目 | 繼承 (Class Inheritance) | 介面 (Interface) |
| :--- | :--- | :--- |
| **口訣** | **Is-A (是一個...)** | **Can-Do (有一個能力...)** |
| **例子** | 柯博文 **是一個** 變形金剛 | 柯博文 **能** 飛行 |
| **特性** | 是天生的、血緣關係、DNA | 是後天的、裝備、技能樹 |
| **限制** | 一個兒子只能有一個親生爸爸 | 一個人可以考很多張證照 (實作多個介面) |
| **變形金剛** | 大家都是金屬做的，都會變形 | 只有飛機跟合體柯博文會飛 |

### 💡 觀念導正
*   如果這是所有東西 **「與生俱來」** 都有的（例如：名字、生命值），寫在 **父類別**。
*   如果這是 **「只有某些人才會」** 的特殊技能（例如：飛行、游泳、魔法攻擊），寫成 **介面**。

這樣，妳的程式碼才不會出現「大黃蜂在天上飛」這種靈異事件喔！
